//-------------------------------------------------------------------------
//   Copyright 2002-2019 National Technology & Engineering Solutions of
//   Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
//   NTESS, the U.S. Government retains certain rights in this software.
//
//   This file is part of the Xyce(TM) Parallel Electrical Simulator.
//
//   Xyce(TM) is free software: you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation, either version 3 of the License, or
//   (at your option) any later version.
//
//   Xyce(TM) is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with Xyce(TM).
//   If not, see <http://www.gnu.org/licenses/>.
//-------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//
// Purpose        : Non-member functions that help the parser.
//
// Special Notes  :
//
// Creator        : Lon Waters, SNL
//
// Creation Date  : 09/06/2001
//
//
//
//
//-----------------------------------------------------------------------------

#include <Xyce_config.h>

#include <algorithm>
#include <iostream>
#include <fstream>
#include <functional>
#include <ctime>

#include <N_DEV_Configuration.h>
#include <N_ERH_ErrorMgr.h>
#include <N_IO_CircuitBlock.h>
#include <N_IO_CmdParse.h>
#include <N_IO_DeviceBlock.h>
#include <N_IO_ParameterBlock.h>
#include <N_IO_ParsingHelpers.h>
#include <N_UTL_ExtendedString.h>
#include <N_UTL_FeatureTest.h>
#include <N_PDS_MPI.h>
#include <N_PDS_Serial.h>

namespace Xyce {
namespace IO {


//--------------------------------------------------------------------------
// Function      : handleIncludeLine
// Purpose       : Handle a netlist .include or .lib line, add the include file
//                 to includeFiles_ for later processing.
// Special Notes :
// Creator       : Lon Waters
// Creation Date : 01/10/2001
//--------------------------------------------------------------------------
void handleIncludeLine(
    const std::string& netlistFileName,
    TokenVector const& parsedLine, const ExtendedString & ES1,
    std::string& includeFile, std::string& libSelect, std::string& libInside)
{
  if ( parsedLine.size() < 2 )
  {
    Report::UserWarning0().at(netlistFileName, parsedLine[0].lineNumber_)
      << ES1 << " is missing argument(s), ignoring";
    return;
  }

  bool lib = ES1.substr(0,4) != ".INC";

  if (!lib || (lib && (parsedLine.size() >= 3)))
  {
    // Get the file name indicated by the .include line.
    std::string includeFileTmp = parsedLine[1].string_;
  
    // Strip off the enclosing double quotes if they are present.
    if ( (includeFileTmp[0] == '"') &&
         (includeFileTmp[includeFileTmp.length()-1] == '"') )
    {
      includeFile = includeFileTmp.substr( 1, includeFileTmp.length()-2 );
    }
    else
    {
      includeFile = includeFileTmp;
    }
  }
  else
  {
    includeFile = "";
  }

  if ( lib )
  {
    if ( parsedLine.size() > 3)
    {
      Report::UserWarning0().at(netlistFileName, parsedLine[0].lineNumber_)
        << "Extraneous data on .LIB ignored";
    }
    // This is a .lib line that is including selected entries of a library.
    if ( parsedLine.size() >= 3 )
    {
      libSelect = ExtendedString(parsedLine[2].string_).toUpper();
      libInside = "";
    }
    // This is a .lib line that is defining a block of netlist entries 
    // that can be selected with a '.lib <libSelect> <libInside>'
    else
    {
      libInside = ExtendedString(parsedLine[1].string_).toUpper();
      libSelect = "";
    }
  }
  else
  {
    if ( parsedLine.size() >= 3)
    {
      Report::UserWarning0().at(netlistFileName, parsedLine[0].lineNumber_)
        << "Extraneous data on .INCLUDE ignored";
    }
  }
}

//--------------------------------------------------------------------------
// Function      : handleEndlLine
// Purpose       : Handle a netlist .endl line
// Special Notes :
// Creator       : Dave Shirley, PSSI
// Creation Date : 10/09/2009
//--------------------------------------------------------------------------
void handleEndlLine(
    const std::string& netlistFileName,
    TokenVector const& parsedLine,
    const std::string& libInside)
{
  if (libInside == "")
  {
    Report::UserError().at(netlistFileName, parsedLine[0].lineNumber_)
      << ".ENDL encountered without .LIB ";
    return;
  }

  if ( parsedLine.size() >= 2 )
  {
    ExtendedString libName ( parsedLine[1].string_ );
    libName.toUpper();
    if (libName != libInside)
    {
      Report::UserError().at(netlistFileName, parsedLine[0].lineNumber_)
        << ".ENDL encountered with name " << libName << ", which does not match .LIB name " << libInside;
    }
    if ( parsedLine.size() >2 )
    {
      Report::UserWarning().at(netlistFileName, parsedLine[0].lineNumber_)
        << "Extraneous field(s) following library name in .ENDL";
    }
  }
  else
  {
    Report::UserError().at(netlistFileName, parsedLine[0].lineNumber_)
      << ".ENDL encountered without library name, currently inside .LIB " << libInside;
  }
}

//--------------------------------------------------------------------------
// Function      : readLine
// Purpose       : Line-terminator-agnostic istream::getline() workalike for
//               : reading a single line from input stream
//
// Special Notes : file ptr is advanced
//               : line terminator is extracted
//--------------------------------------------------------------------------
void readLine( std::istream & in, std::string& line )
{
  line.clear();
  char c;

  // read all characters into line
  while( in.good() )
  {
    // read a char and append to line
    in.get( c );

    if ( in.eof() || c == '\n' )
    {
      return;
    }
    else if( c == '\r' )
    {
      if( in.peek() == '\n' )
      {
        // extract the CR LF pair and discard
        in.get();
      }

      return;
    }
    else
    {
      line.push_back( c );
    }
  }
}

//----------------------------------------------------------------------------
// Function       : splitLine
// Purpose        : Split an input character string into a tokenized vector.
// Special Notes  :
// Scope          : public
// Creator        : Heidi Thornquist
// Creation Date  : 10/15/2014
//----------------------------------------------------------------------------
void splitLine( const std::string& charLine, 
                TokenVector& line )
{
  int lineLength = charLine.length();
  int currPtr = 0;
  char c=charLine[ currPtr ];
  const std::string nonid(" \t\n\r\0");
  line.clear();

  while ( currPtr < lineLength )
  {
    StringToken field;
    field.string_.reserve(16);

    if (nonid.find(c) == nonid.npos) //not a whitespace character
    {
      field.string_ += c;
      c = charLine[ ++currPtr ];
      while ( currPtr < lineLength )
      {
        if (nonid.find(c) == nonid.npos)
        {
          field.string_ += c;
          c = charLine[ ++currPtr ];
        }
        else
        {
          break;
        }
      }
    }
    else
    {
      if (c == '\n' || c == '\r' || c == '\0')
      {
        field.string_ += c;
      }
      else
      {
        field.string_ += c;
        c = charLine[ ++currPtr ];
      }
    }

    if (field.string_.length() > 0)
    {
      line.push_back(field);
    }
  }
}

//----------------------------------------------------------------------------
// Function       : splitLineNoWS
// Purpose        : Split an input character string into a tokenized vector.
// Special Notes  : No whitespace will be in the TokenVector
// Scope          : public
// Creator        : Heidi Thornquist
// Creation Date  : 10/15/2014
//----------------------------------------------------------------------------
void splitLineNoWS( const std::string& charLine, 
                    TokenVector& line )
{
  int lineLength = charLine.length();
  int currPtr = 0;
  char c=charLine[ currPtr ];
  const std::string nonid(" \t\n\r\0");
  line.clear();

  while ( currPtr < lineLength )
  {
    StringToken field;
    field.string_.reserve(16);

    if (nonid.find(c) == nonid.npos) //not a whitespace character
    {
      field.string_ += c;
      c = charLine[ ++currPtr ];
      while ( currPtr < lineLength )
      {
        if (nonid.find(c) == nonid.npos)
        {
          field.string_ += c;
          c = charLine[ ++currPtr ];
        }
        else
        {
          break;
        }
      }
    }
    else
    {
      if (c != '\n' && c != '\r' && c != '\0')
      {
        c = charLine[ ++currPtr ];
      }
    }

    if (field.string_.length() > 0)
    {
      line.push_back(field);
    }
  }
}

//--------------------------------------------------------------------------
// Function      : removeTwoTerminalDevice
// Purpose       : Given a two terminal device, this function checks to see
//                 if both nodes on the device are the same and, if so,
//                 decides whether or not the device should be removed
//                 from the circuit.  The decision to remove is based upon
//                 whether the specific device type was specified during the
//                 preprocessing phase as a device for which redundancies
//                 should be removed.  E.g., if the lines
//
//                 .PREPROCESS REMOVEUNUSED C
//                 C1 1 1 1
//                 R1 2 2 1
//
//                 appear in the netlist, the capacitor C1 will be removed
//                 from the netlist, whereas the resistor R1 will not.
//
// Special Notes : This function only determines *whether* a specific device
//                 should be removed; the process of removing the device from
//                 the netlist takes place in the handleLinePass1 and
//                 getLinePass2 functions.
//
// Creator       : Keith Santarelli
//
// Creation Date : 10/08/2007
//--------------------------------------------------------------------------
bool removeTwoTerminalDevice(const std::vector<bool>& pFilter,
                             const char& linetype,
                             const ExtendedString & node1, 
                             const ExtendedString & node2)
{
  bool result=false;

  if ( ( pFilter[PreprocessType::REDUNDANT_C] && linetype == 'C') 
     || ( pFilter[PreprocessType::REDUNDANT_D] && linetype == 'D') 
     || ( pFilter[PreprocessType::REDUNDANT_I] && linetype == 'I') 
     || ( pFilter[PreprocessType::REDUNDANT_L] && linetype == 'L') 
     || ( pFilter[PreprocessType::REDUNDANT_R] && linetype == 'R')
     || ( pFilter[PreprocessType::REDUNDANT_V] && linetype == 'V') )
  {
    if (node1 == node2)
    {
      result=true;
    }
  }

  return result;
}

//--------------------------------------------------------------------------
// Function      : removeThreeTerminalDevice
// Purpose       : Given a three terminal device, this function checks to see
//                 if all three nodes on the device are the same and, if so,
//                 decides whether or not the device should be removed
//                 from the circuit.  The decision to remove is based upon
//                 whether the specific device type was specified during the
//                 preprocessing phase as a device for which redundancies
//                 should be removed.  E.g., if the lines
//
//                 .PREPROCESS REMOVEUNUSED M
//                 M1 1 1 1 4 NMOS
//                 Q1 2 2 2 5 NPN
//
//                 appear in the netlist, the MOSFET M1 will be removed
//                 from the netlist, whereas the BJT Q1 will not.
//
// Special Notes : This function only determines *whether* a specific device
//                 should be removed; the process of removing the device from
//                 the netlist takes place in the handleLinePass1 and
//                 getLinePass2 functions.
//
// Creator       : Keith Santarelli
//
// Creation Date : 10/10/2007
//--------------------------------------------------------------------------
bool removeThreeTerminalDevice(const std::vector<bool>& pFilter,
                               const char& linetype,
                               const ExtendedString & node1,
                               const ExtendedString & node2,
                               const ExtendedString & node3)
{
  bool result=false;

  // Check three terminal devices.
  if ( (pFilter[PreprocessType::REDUNDANT_M] && linetype == 'M') 
        || (pFilter[PreprocessType::REDUNDANT_Q] && linetype == 'Q') )
  {
    if (node1 == node2 && node2 == node3)
    { 
      result=true;
    }
  }

  return result;
}


//--------------------------------------------------------------------------
// Function      : removeDevice
// Purpose       : Given a device block, this function checks to see
//                 if all the nodes on the device are the same and, if so,
//                 decides whether or not the device should be removed
//                 from the circuit.  The decision to remove is based upon
//                 whether the specific device type was specified during the
//                 preprocessing phase as a device for which redundancies
//                 should be removed.  E.g., if the lines
//
//                 .PREPROCESS REMOVEUNUSED M
//                 M1 1 1 1 4 NMOS
//                 Q1 2 2 2 5 NPN
//
//                 appear in the netlist, the MOSFET M1 will be removed
//                 from the netlist, whereas the BJT Q1 will not.
//
// Creator       : Heidi Thornquist
//
// Creation Date : 11/9/2015
//--------------------------------------------------------------------------
bool removeDevice(const std::vector<bool>& pFilter,
                  const DeviceBlock& device)
{ 
  bool result=false;
 
  // Get the vector of nodes from the device
  const std::vector<std::string> & nodes = device.getNodeValues();
  std::string linetype = device.getNetlistDeviceType();
  
  // Check two terminal devices.
  if ( ( pFilter[PreprocessType::REDUNDANT_C] && linetype == "C")
     || ( pFilter[PreprocessType::REDUNDANT_D] && linetype == "D")
     || ( pFilter[PreprocessType::REDUNDANT_I] && linetype == "I") 
     || ( pFilter[PreprocessType::REDUNDANT_L] && linetype == "L") 
     || ( pFilter[PreprocessType::REDUNDANT_R] && linetype == "R")
     || ( pFilter[PreprocessType::REDUNDANT_V] && linetype == "V") )
  { 
    if (nodes[0] == nodes[1])
    { 
      result=true;
    }
  }

  // Check three terminal devices.
  if ( (pFilter[PreprocessType::REDUNDANT_M] && linetype == "M") 
        || (pFilter[PreprocessType::REDUNDANT_Q] && linetype == "Q") )
  {
    if (nodes[0] == nodes[1] && nodes[1] == nodes[2])
    { 
      result=true;
    }
  }

  return result;
}

//---------------------------------------------------------------------------
// Function      : readExternalParamsFromFile
// Purpose       :
// Special Notes : Used to read parameters "tag" = "value" from an external
//                 file.  Any "tag"s found while reading the netlist during
//                 parsing will be replaced by "value".
// Scope         : public
// Creator       : Richard Schiek, 1437 Electrical Systems Modeling
// Creation Date : 07/24/2012
//---------------------------------------------------------------------------
void readExternalParamsFromFile( N_PDS_Comm& comm,
  std::string filename,
  std::vector< std::pair< std::string, std::string > > & paramList )
{
  // at this stage just support the Dakota params.in format of "value" = "tag".
  // we could support other formats as well.

  bool validFile = Util::checkIfValidFile(filename);

  // These parameters are read in on one processor and communicated to the others.
  if (comm.procID() == 0 && validFile)
  {
    const std::string allowedChars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890_.$");
    const std::string whiteSpace(" \t=\n\r");    // note we will treat "=" as whitespace
    const std::string commentChars("*#;");  // if we find any of these then the rest of the line is a comment

    // open the params file and read its content
    std::ifstream paramFile(filename.c_str(), std::ios::in);
    if( paramFile.good() )
    {
      // loop over the file trying to gather names / values and response functions required.
      // general format:
      // white space tag/value white space or = tag/value
      //
      std::string aLine;
      getline(paramFile, aLine);
      bool word1IsNumeric = false;
      while ( paramFile.good() )
      {
        // getline worked, so try to parse the line
        // procedure (1) discard any comments
        //           (2) find tag/value boundaries by looking for allowedChars followed by whitespace
        //           (3) sort out order of tag/value pair
        //           (4) store pair in paramList
        //           (5) try to get another line

        // don't bother with lines that are blank or essentially blank (i.e. just \r\n)
        // shortest line we could have is x=1 or 3 chars.
        if( aLine.length() > 2 )
        {
          std::string::size_type commentLoc = aLine.find_first_of( commentChars, 0 );
          if( commentLoc != std::string::npos )
          {
            // chop off comment to end of line.
            aLine.erase( commentLoc, aLine.length()-commentLoc );
          }
          //check overall line length again.  This could have been just a comment line
          if( aLine.length() > 2 )
          {
            std::string::size_type word1Start = aLine.find_first_of( allowedChars, 0 );
            // check that we found a valid word1Start otherwise stop trying to parse this line.
            if( word1Start != std::string::npos )
            {
              std::string::size_type word1End   = aLine.find_first_of( whiteSpace, word1Start );
              // check that we found a valid word1End otherwise stop trying to parse this line.
              if( word1End != std::string::npos )
              {
                std::string::size_type word2Start = aLine.find_first_of( allowedChars, word1End );
                // check that we found a valid word2Start otherwise stop trying to parse this line.
                if( word2Start != std::string::npos )
                {
                  std::string::size_type word2End   = aLine.find_first_of( whiteSpace, word2Start );
                  // check that we found a valid word2End
                  if( word2End == std::string::npos )
                    word2End = aLine.length();
                  // if we get here then we have valid start,end indicies for word1 and word2
 
                  std::string word1=aLine.substr( word1Start, (word1End - word1Start) );
                  std::string word2=aLine.substr( word2Start, (word2End - word2Start) );

                  // sort out tag/value ordering.
                  // if word1=number assume format is value = tag
                  // otherwise assume format is tag = value
                  std::stringstream converter;
                  converter << word1;
                  double testvalue;
                  converter >> testvalue;
                  if( converter.fail() && !word1IsNumeric )
                  {
                    // couldn't convert tag1 to a double value so assume format is word1=tag word2=value
                    paramList.push_back( std::pair<std::string,std::string>(word1,word2) );
                  }
                  else
                  {
                    // tag1 was successfully converted to a value so assume format is word1=value word2=tag
                    paramList.push_back( std::pair<std::string,std::string>(word2,word1) );
                    word1IsNumeric=true;
                  }

                }  // if ( word2Start != std::string::npos )
              }    // if( word1End != std::string::npos )
            }      // if( word1Start != std::string::npos )
          }        // if( aLine.length() > 2 ) -- check after removing comments
        }          // if( aLine.length() > 2 ) -- outer check
        // try to get another line
        getline(paramFile, aLine);
      }
    }
    else
    {
      validFile = false;
    }
  }

  // Generate a warning if the user-specified params file does not exist, cannot
  // be opened, or is a directory name rather than a file name.  See SON Bugs 730
  // and 785 for more details.
  if ( comm.procID()==0 && !validFile )
  {
    Report::UserWarning() << "Could not find parameter file: " + filename + "  Attempting to continue.";
  }

  // Broadcast the parameters to all the other processors in parallel.
  if (comm.numProc() > 1)
  {
    int numParams = paramList.size();
    comm.bcast( &numParams, 1, 0 );

    for (int i=0; i<numParams; i++)
    {
      int* len = new int[2];

      // Processor zero packs the param.
      char *paramFirst = 0, *paramSecond = 0;
      if (comm.procID() == 0)
      {
        len[0] = paramList[i].first.length();
        len[1] = paramList[i].second.length();
        paramFirst = new char[len[0]+1];
        std::strcpy( paramFirst, paramList[i].first.c_str() );
        paramSecond = new char[len[1]+1];
        std::strcpy( paramSecond, paramList[i].second.c_str() );
      }

      // All other processors receive param lengths
      comm.bcast(len,2,0);
      if (paramFirst == 0)
      {
        paramFirst = new char[len[0]+1];
        paramSecond = new char[len[1]+1];
      }
      comm.bcast(paramFirst,len[0]+1,0);
      comm.bcast(paramSecond,len[1]+1,0);

      // Create pair.
      if (comm.procID() != 0)
      {
        std::string pF( paramFirst );
        std::string pS( paramSecond );
        paramList.push_back( std::pair<std::string,std::string>(pF,pS) );
      }

      delete [] len;
      delete [] paramFirst;
      delete [] paramSecond;
    }    
  }

  // for debug purposes.  output the params as read
  dout() << "Parameters read from \"" << filename << "\"" << std::endl;
  std::vector< std::pair< std::string, std::string > >::iterator listitr = paramList.begin();
  std::vector< std::pair< std::string, std::string > >::iterator enditr = paramList.end();
  while( listitr != enditr )
  {
    dout() << "  " << listitr->first << " , " << listitr->second << std::endl;
    listitr++;
  }
}


} // namespace IO
} // namespace Xyce
