
//-------------------------------------------------------------------------
//   Copyright 2002-2019 National Technology & Engineering Solutions of
//   Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
//   NTESS, the U.S. Government retains certain rights in this software.
//
//   This file is part of the Xyce(TM) Parallel Electrical Simulator.
//
//   Xyce(TM) is free software: you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation, either version 3 of the License, or
//   (at your option) any later version.
//
//   Xyce(TM) is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with Xyce(TM).
//   If not, see <http://www.gnu.org/licenses/>.
//-------------------------------------------------------------------------


//-------------------------------------------------------------------------
//
// Purpose        :
//
// Special Notes  : Generated from verilog file mvs_2_0_0_hemt.va with ADMS
//                  interface for Xyce 6.12.0
//                  DO NOT EDIT THIS FILE DIRECTLY!  It may be overwritten!
//
//                  THIS FILE WAS GENERATED WITH AN EXPERIMENTAL VERSION
//                  OF XYCE/ADMS THAT HAS NOT BEEN RELEASED YET.
//                  Do not regenerate this file using the released version,
//                  or you will lose the optimizations that can be performed
//                  by the experimental code.
//
// Creator        : admsXml-2.3.6
//
// Creation Date  : Mon, 08 Apr 2019 13:47:33
//
//-------------------------------------------------------------------------
// Shut up clang's warnings about extraneous parentheses
#ifdef __clang__
#  pragma clang diagnostic ignored "-Wparentheses-equality"
#endif

#include <Xyce_config.h>
#include <N_DEV_ADMSmvs_2_0_0_hemt.h>


#include <N_DEV_Const.h>
#include <N_DEV_DeviceOptions.h>
#include <N_DEV_DeviceMaster.h>
#include <N_DEV_ExternData.h>
#include <N_DEV_SolverState.h>
#include <N_DEV_Message.h>

#include <N_LAS_Matrix.h>
#include <N_LAS_Vector.h>


#include <N_UTL_FeatureTest.h>
#if defined(HAVE_UNORDERED_MAP)
#include <unordered_map>
using std::unordered_map;
#elif defined(HAVE_TR1_UNORDERED_MAP)
#include <tr1/unordered_map>
using std::tr1::unordered_map;
#else
#error neither unordered_map or tr1/unordered_map found
#endif

#include <algorithm>

namespace Xyce {
namespace Device {
namespace ADMSmvs_2_0_0_hemt {
JacobianStamp Instance::jacStamp;
IdVector Instance::nodeMap;
PairMap Instance::pairToJacStampMap;


//This is necessary because the IntPair usage can trip undefined references
const int Instance::admsNodeID_d;
const int Instance::admsNodeID_g;
const int Instance::admsNodeID_s;
const int Instance::admsNodeID_di;
const int Instance::admsNodeID_si;
const int Instance::admsNodeID_sf;
const int Instance::admsNodeID_GND;
// Additional IDs for branch equations
const int Instance::admsBRA_ID_sf_GND;


void
Traits::loadInstanceParameters(ParametricData<ADMSmvs_2_0_0_hemt::Instance> &p)
{
  // Set up each parameter directly, using the up-cased variable name
  // as the tag.

  // This kludge is to force us always to have an instance parameter
  // that the device manager can set to the temperature, even if we have
  // no "TEMP".
  p.addPar("XYCEADMSINSTTEMP", 0.0, &ADMSmvs_2_0_0_hemt::Instance::admsInstTemp)
    .setExpressionAccess(NO_DOC)
    .setUnit(U_DEGK)
    .setCategory(CAT_TEMP)
    .setDescription("Internal-use parameter for setting device instance temperature");


}

void Traits::loadModelParameters(ParametricData<ADMSmvs_2_0_0_hemt::Model> &p)
{
  // Set up each parameter directly, using the up-cased variable name
  // as the tag.

  // This kludge is to force us always to have a model parameter
  // that the device manager can set to the temperature, even if we have
  // no "TEMP".
  p.addPar("XYCEADMSMODTEMP", 0.0, &ADMSmvs_2_0_0_hemt::Model::admsModTemp)
    .setExpressionAccess(NO_DOC)
    .setUnit(U_DEGK)
    .setCategory(CAT_TEMP)
    .setDescription("Internal-use parameter for setting device model temperature");
  p.addPar("VERSION", static_cast<double>(2.00), &ADMSmvs_2_0_0_hemt::Model::version)
#ifdef Xyce_ADMS_SENSITIVITIES
    .setAnalyticSensitivityAvailable(true)
    .setSensitivityFunctor(&modSens)
#endif // Xyce_ADMS_SENSITIVITIES
    ;
  p.addPar("TYPE", static_cast<int>(1), &ADMSmvs_2_0_0_hemt::Model::type);
  p.addPar("W", static_cast<double>(1.0e-6), &ADMSmvs_2_0_0_hemt::Model::W)
#ifdef Xyce_ADMS_SENSITIVITIES
    .setAnalyticSensitivityAvailable(true)
    .setSensitivityFunctor(&modSens)
#endif // Xyce_ADMS_SENSITIVITIES
    ;
  p.addPar("LGDR", static_cast<double>(80.0e-9), &ADMSmvs_2_0_0_hemt::Model::Lgdr)
#ifdef Xyce_ADMS_SENSITIVITIES
    .setAnalyticSensitivityAvailable(true)
    .setSensitivityFunctor(&modSens)
#endif // Xyce_ADMS_SENSITIVITIES
    ;
  p.addPar("DLG", static_cast<double>(10.5e-9), &ADMSmvs_2_0_0_hemt::Model::dLg)
#ifdef Xyce_ADMS_SENSITIVITIES
    .setAnalyticSensitivityAvailable(true)
    .setSensitivityFunctor(&modSens)
#endif // Xyce_ADMS_SENSITIVITIES
    ;
  p.addPar("CINS", static_cast<double>(3.17e-2), &ADMSmvs_2_0_0_hemt::Model::Cins)
#ifdef Xyce_ADMS_SENSITIVITIES
    .setAnalyticSensitivityAvailable(true)
    .setSensitivityFunctor(&modSens)
#endif // Xyce_ADMS_SENSITIVITIES
    ;
  p.addPar("TJUN", static_cast<double>(300.0), &ADMSmvs_2_0_0_hemt::Model::Tjun)
#ifdef Xyce_ADMS_SENSITIVITIES
    .setAnalyticSensitivityAvailable(true)
    .setSensitivityFunctor(&modSens)
#endif // Xyce_ADMS_SENSITIVITIES
    ;
  p.addPar("ENERGY_DIFF_VOLT", static_cast<double>(0.153), &ADMSmvs_2_0_0_hemt::Model::energy_diff_volt)
#ifdef Xyce_ADMS_SENSITIVITIES
    .setAnalyticSensitivityAvailable(true)
    .setSensitivityFunctor(&modSens)
#endif // Xyce_ADMS_SENSITIVITIES
    ;
  p.addPar("DELTA", static_cast<double>(0.120), &ADMSmvs_2_0_0_hemt::Model::delta)
#ifdef Xyce_ADMS_SENSITIVITIES
    .setAnalyticSensitivityAvailable(true)
    .setSensitivityFunctor(&modSens)
#endif // Xyce_ADMS_SENSITIVITIES
    ;
  p.addPar("N0", static_cast<double>(1.35), &ADMSmvs_2_0_0_hemt::Model::n0)
#ifdef Xyce_ADMS_SENSITIVITIES
    .setAnalyticSensitivityAvailable(true)
    .setSensitivityFunctor(&modSens)
#endif // Xyce_ADMS_SENSITIVITIES
    ;
  p.addPar("RC0", static_cast<double>(160.0e-6), &ADMSmvs_2_0_0_hemt::Model::Rc0)
#ifdef Xyce_ADMS_SENSITIVITIES
    .setAnalyticSensitivityAvailable(true)
    .setSensitivityFunctor(&modSens)
#endif // Xyce_ADMS_SENSITIVITIES
    ;
  p.addPar("NACC", static_cast<double>(2.25e16), &ADMSmvs_2_0_0_hemt::Model::nacc)
#ifdef Xyce_ADMS_SENSITIVITIES
    .setAnalyticSensitivityAvailable(true)
    .setSensitivityFunctor(&modSens)
#endif // Xyce_ADMS_SENSITIVITIES
    ;
  p.addPar("MEFF", static_cast<double>(0.041), &ADMSmvs_2_0_0_hemt::Model::meff)
#ifdef Xyce_ADMS_SENSITIVITIES
    .setAnalyticSensitivityAvailable(true)
    .setSensitivityFunctor(&modSens)
#endif // Xyce_ADMS_SENSITIVITIES
    ;
  p.addPar("NP_MASS", static_cast<double>(9.0), &ADMSmvs_2_0_0_hemt::Model::np_mass)
#ifdef Xyce_ADMS_SENSITIVITIES
    .setAnalyticSensitivityAvailable(true)
    .setSensitivityFunctor(&modSens)
#endif // Xyce_ADMS_SENSITIVITIES
    ;
  p.addPar("MU_EFF", static_cast<double>(1.0), &ADMSmvs_2_0_0_hemt::Model::mu_eff)
#ifdef Xyce_ADMS_SENSITIVITIES
    .setAnalyticSensitivityAvailable(true)
    .setSensitivityFunctor(&modSens)
#endif // Xyce_ADMS_SENSITIVITIES
    ;
  p.addPar("KSEE", static_cast<double>(0.1), &ADMSmvs_2_0_0_hemt::Model::ksee)
#ifdef Xyce_ADMS_SENSITIVITIES
    .setAnalyticSensitivityAvailable(true)
    .setSensitivityFunctor(&modSens)
#endif // Xyce_ADMS_SENSITIVITIES
    ;
  p.addPar("B", static_cast<double>(6.8e-9), &ADMSmvs_2_0_0_hemt::Model::B)
#ifdef Xyce_ADMS_SENSITIVITIES
    .setAnalyticSensitivityAvailable(true)
    .setSensitivityFunctor(&modSens)
#endif // Xyce_ADMS_SENSITIVITIES
    ;
  p.addPar("DQM0", static_cast<double>(4.6e-9), &ADMSmvs_2_0_0_hemt::Model::dqm0)
#ifdef Xyce_ADMS_SENSITIVITIES
    .setAnalyticSensitivityAvailable(true)
    .setSensitivityFunctor(&modSens)
#endif // Xyce_ADMS_SENSITIVITIES
    ;
  p.addPar("EPS", static_cast<double>(13.6), &ADMSmvs_2_0_0_hemt::Model::eps)
#ifdef Xyce_ADMS_SENSITIVITIES
    .setAnalyticSensitivityAvailable(true)
    .setSensitivityFunctor(&modSens)
#endif // Xyce_ADMS_SENSITIVITIES
    ;
  p.addPar("THETA", static_cast<double>(2.5), &ADMSmvs_2_0_0_hemt::Model::theta)
#ifdef Xyce_ADMS_SENSITIVITIES
    .setAnalyticSensitivityAvailable(true)
    .setSensitivityFunctor(&modSens)
#endif // Xyce_ADMS_SENSITIVITIES
    ;
  p.addPar("BETA", static_cast<double>(1.55), &ADMSmvs_2_0_0_hemt::Model::beta)
#ifdef Xyce_ADMS_SENSITIVITIES
    .setAnalyticSensitivityAvailable(true)
    .setSensitivityFunctor(&modSens)
#endif // Xyce_ADMS_SENSITIVITIES
    ;
  p.addPar("ND", static_cast<double>(0.0), &ADMSmvs_2_0_0_hemt::Model::nd)
#ifdef Xyce_ADMS_SENSITIVITIES
    .setAnalyticSensitivityAvailable(true)
    .setSensitivityFunctor(&modSens)
#endif // Xyce_ADMS_SENSITIVITIES
    ;

}

//-----------------------------------------------------------------------------
// Function      : Instance::processParams
// Purpose       :
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
//-----------------------------------------------------------------------------
bool Instance::processParams()
{
  // set any non-constant parameter defaults

  // copy any model variables that have associated instance variables, but
  // are only given in the model card:



  // Set any parameters that were not given and whose defaults depend on other
  // parameters:


  // Now we need to check that any parameters are within their ranges as
  // specified in the verilog:


  // this seems a little stupid, but verilog models that use $temperature
  // don't also use a defined parameter "Temp", and count on $temperature
  // to be the one the simulator wants:

  updateTemperature(admsInstTemp);

  // and of course, this routine is where we should put the initial_instance
  // stuff


  return true;
}

//-----------------------------------------------------------------------------
// Function      : Instance::Instance
// Purpose       : "instance block" constructor
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
//-----------------------------------------------------------------------------

Instance::Instance(
   const Configuration & configuration,
   const InstanceBlock & instance_block,
   Model &               model,
   const FactoryBlock &  factory_block)
  : DeviceInstance(instance_block, configuration.getInstanceParameters(), factory_block),
    model_(model),
    li_d(-1),
    li_g(-1),
    li_s(-1),
    li_di(-1),
    li_si(-1),
    li_sf(-1),
    li_BRA_sf_GND(-1),
    li_branch_id(-1),
    li_branch_ig(-1),
    li_branch_is(-1),
    f_di_Equ_si_Node_Ptr(0),
    f_si_Equ_si_Node_Ptr(0),
    f_di_Equ_di_Node_Ptr(0),
    f_si_Equ_di_Node_Ptr(0),
    f_di_Equ_sf_Node_Ptr(0),
    f_si_Equ_sf_Node_Ptr(0),
    f_d_Equ_si_Node_Ptr(0),
    f_d_Equ_sf_Node_Ptr(0),
    f_d_Equ_di_Node_Ptr(0),
    f_d_Equ_d_Node_Ptr(0),
    f_di_Equ_d_Node_Ptr(0),
    f_s_Equ_di_Node_Ptr(0),
    f_s_Equ_sf_Node_Ptr(0),
    f_si_Equ_s_Node_Ptr(0),
    f_s_Equ_s_Node_Ptr(0),
    f_s_Equ_si_Node_Ptr(0),
    f_sf_Equ_BRA_sf_GND_Var_Ptr(0),
    f_BRA_sf_GND_Equ_sf_Node_Ptr(0),
    f_BRA_sf_GND_Equ_si_Node_Ptr(0),
    f_BRA_sf_GND_Equ_g_Node_Ptr(0),
    f_BRA_sf_GND_Equ_di_Node_Ptr(0),
    q_di_Equ_si_Node_Ptr(0),
    q_si_Equ_si_Node_Ptr(0),
    q_di_Equ_di_Node_Ptr(0),
    q_si_Equ_di_Node_Ptr(0),
    q_di_Equ_sf_Node_Ptr(0),
    q_si_Equ_sf_Node_Ptr(0),
    q_d_Equ_si_Node_Ptr(0),
    q_d_Equ_sf_Node_Ptr(0),
    q_d_Equ_di_Node_Ptr(0),
    q_d_Equ_d_Node_Ptr(0),
    q_di_Equ_d_Node_Ptr(0),
    q_s_Equ_di_Node_Ptr(0),
    q_s_Equ_sf_Node_Ptr(0),
    q_si_Equ_s_Node_Ptr(0),
    q_s_Equ_s_Node_Ptr(0),
    q_s_Equ_si_Node_Ptr(0),
    q_sf_Equ_BRA_sf_GND_Var_Ptr(0),
    q_BRA_sf_GND_Equ_sf_Node_Ptr(0),
    q_BRA_sf_GND_Equ_si_Node_Ptr(0),
    q_BRA_sf_GND_Equ_g_Node_Ptr(0),
    q_BRA_sf_GND_Equ_di_Node_Ptr(0),
    A_di_Equ_si_NodeOffset(-1),
    A_si_Equ_si_NodeOffset(-1),
    A_di_Equ_di_NodeOffset(-1),
    A_si_Equ_di_NodeOffset(-1),
    A_di_Equ_sf_NodeOffset(-1),
    A_si_Equ_sf_NodeOffset(-1),
    A_d_Equ_si_NodeOffset(-1),
    A_d_Equ_sf_NodeOffset(-1),
    A_d_Equ_di_NodeOffset(-1),
    A_d_Equ_d_NodeOffset(-1),
    A_di_Equ_d_NodeOffset(-1),
    A_s_Equ_di_NodeOffset(-1),
    A_s_Equ_sf_NodeOffset(-1),
    A_si_Equ_s_NodeOffset(-1),
    A_s_Equ_s_NodeOffset(-1),
    A_s_Equ_si_NodeOffset(-1),
    A_sf_Equ_BRA_sf_GND_Var_Offset(-1),
    A_BRA_sf_GND_Equ_sf_Node_Offset(-1),
    A_BRA_sf_GND_Equ_si_Node_Offset(-1),
    A_BRA_sf_GND_Equ_g_Node_Offset(-1),
    A_BRA_sf_GND_Equ_di_Node_Offset(-1),
    admsTemperature(getDeviceOptions().temp.getImmutableValue<double>())

{
  numIntVars = 3 + 1;
  numExtVars = 3;


  // Right now, we only have store for limited probes...
  setNumStoreVars(0);

  // Do not allocate "branch" (lead current) vectors by default
  setNumBranchDataVars(0);
  numBranchDataVarsIfAllocated = 3;

  leadCurrentF.resize(3);
  leadCurrentQ.resize(3);

  // Set up jacobian stamp:
  // Create a vector of the non-zero elements of the stamp
  PairVector jacobianElements;
  jacobianElements.push_back(IntPair(admsNodeID_d,admsNodeID_si));
  jacobianElements.push_back(IntPair(admsNodeID_d,admsNodeID_sf));
  jacobianElements.push_back(IntPair(admsNodeID_d,admsNodeID_di));
  jacobianElements.push_back(IntPair(admsNodeID_d,admsNodeID_d));
  jacobianElements.push_back(IntPair(admsNodeID_s,admsNodeID_di));
  jacobianElements.push_back(IntPair(admsNodeID_s,admsNodeID_sf));
  jacobianElements.push_back(IntPair(admsNodeID_s,admsNodeID_s));
  jacobianElements.push_back(IntPair(admsNodeID_s,admsNodeID_si));
  jacobianElements.push_back(IntPair(admsNodeID_di,admsNodeID_si));
  jacobianElements.push_back(IntPair(admsNodeID_di,admsNodeID_di));
  jacobianElements.push_back(IntPair(admsNodeID_di,admsNodeID_sf));
  jacobianElements.push_back(IntPair(admsNodeID_di,admsNodeID_d));
  jacobianElements.push_back(IntPair(admsNodeID_si,admsNodeID_si));
  jacobianElements.push_back(IntPair(admsNodeID_si,admsNodeID_di));
  jacobianElements.push_back(IntPair(admsNodeID_si,admsNodeID_sf));
  jacobianElements.push_back(IntPair(admsNodeID_si,admsNodeID_s));
  // Extra columns for dependence on branches
  jacobianElements.push_back(IntPair(admsNodeID_sf,admsBRA_ID_sf_GND));
  // Jacobian rows for branch equations
  jacobianElements.push_back(IntPair(admsBRA_ID_sf_GND,admsNodeID_sf));   // Branch eqn sf,GND - node sf
  jacobianElements.push_back(IntPair(admsBRA_ID_sf_GND,admsNodeID_si));   // Branch eqn sf,GND - node si
  jacobianElements.push_back(IntPair(admsBRA_ID_sf_GND,admsNodeID_g));   // Branch eqn sf,GND - node g
  jacobianElements.push_back(IntPair(admsBRA_ID_sf_GND,admsNodeID_di));   // Branch eqn sf,GND - node di



  setDefaultParams();
  setParams(instance_block.params);

  // Real bogosity here...
  if (!given("XYCEADMSINSTTEMP"))
    admsInstTemp=getDeviceOptions().temp.getImmutableValue<double>();

  //calculate any parameters specified as expressions
  updateDependentParameters();

  // calculate dependent (i.e. computed params) and check for errors.
  processParams();

  PairVector collapsedNodes;

  // Now generate the jacstamp from what we already have.
  // This jacstamp will have all the correct node mapping.  map will be the nodal mapping of original
  // node IDs to row/column ids in the reduced (non-sparse) representation of the jacobian.
  // (for devices that have no collapsibles, this will be static, so check that it hasn't already
  // been filled in)
  if (jacStamp.empty())
  {
    int originalSize = 6+1;
    computeJacStampAndMaps(jacobianElements,collapsedNodes,jacStamp,nodeMap,pairToJacStampMap,originalSize);
  }

}

//-----------------------------------------------------------------------------
// Function      : Instance::~Instance
// Purpose       : destructor
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
//-----------------------------------------------------------------------------
Instance::~Instance()
{
}

//-----------------------------------------------------------------------------
// Function      : Instance::registerLIDs
// Purpose       : function for registering, and setting up, local ID's.
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
//-----------------------------------------------------------------------------
void Instance::registerLIDs( const LocalIdVector & intLIDVecRef,
                             const LocalIdVector & extLIDVecRef)
{
  AssertLIDs(intLIDVecRef.size() == numIntVars);
  AssertLIDs(extLIDVecRef.size() == numExtVars);

  LocalIdVector localLIDVec;

  if (DEBUG_DEVICE && isActive(Diag::DEVICE_PARAMETERS))
  {
    Xyce::dout() << std::endl << section_divider << std::endl
                 << "In ADMSmvs_2_0_0_hemt::Instance::register LIDs\n\n"
                 << "name             = " << getName() << std::endl
                 << "number of internal variables: " << numIntVars << std::endl
                 << "number of external variables: " << numExtVars << std::endl;
  }

  // copy over the global ID lists into a local array.
  // The end result of this is an array of LIDs corresponding to all the
  // nodes we actually have, in the order that topology thinks of them
  intLIDVec = intLIDVecRef;
  extLIDVec = extLIDVecRef;
  localLIDVec.resize(numExtVars+numIntVars);
  for (int localNodeIndex=0;localNodeIndex<numExtVars;++localNodeIndex)
  {
    localLIDVec[localNodeIndex]=extLIDVec[localNodeIndex];
  }
  for (int localNodeIndex=numExtVars;localNodeIndex<numExtVars+numIntVars;++localNodeIndex)
  {
    localLIDVec[localNodeIndex]=intLIDVec[localNodeIndex-numExtVars];
  }

  // Now pull the LIDs for each of our nodes out of the local array.
  // Use the node mapping created by createJacStampAndMaps to handle
  // all the node collapse complications.
  li_d = localLIDVec[nodeMap[admsNodeID_d]];
  li_g = localLIDVec[nodeMap[admsNodeID_g]];
  li_s = localLIDVec[nodeMap[admsNodeID_s]];
  li_di = localLIDVec[nodeMap[admsNodeID_di]];
  li_si = localLIDVec[nodeMap[admsNodeID_si]];
  li_sf = localLIDVec[nodeMap[admsNodeID_sf]];
  li_BRA_sf_GND = localLIDVec[nodeMap[admsBRA_ID_sf_GND]];


  if (DEBUG_DEVICE && isActive(Diag::DEVICE_PARAMETERS))
  {
    Xyce::dout() << "\nSolution and RHS variables:\n";
    Xyce::dout() << "\nli_d = " << li_d << std::endl;
    Xyce::dout() << "\nli_g = " << li_g << std::endl;
    Xyce::dout() << "\nli_s = " << li_s << std::endl;
    Xyce::dout() << "\nli_di = " << li_di << std::endl;
    Xyce::dout() << "\nli_si = " << li_si << std::endl;
    Xyce::dout() << "\nli_sf = " << li_sf << std::endl;
    Xyce::dout() << "\nli_BRA_sf_GND = " << li_BRA_sf_GND << std::endl;

    Xyce::dout() << "\nEnd of ADMSmvs_2_0_0_hemt::Instance::register LIDs\n";
    Xyce::dout() << section_divider << std::endl;
  }
}

//-----------------------------------------------------------------------------
// Function      : Instance::loadNodeSymbols
// Purpose       :
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
//-----------------------------------------------------------------------------
void Instance::loadNodeSymbols(Util::SymbolTable &symbol_table) const
{
  addInternalNode(symbol_table, li_di, getName(), "di");
  addInternalNode(symbol_table, li_si, getName(), "si");
  addInternalNode(symbol_table, li_sf, getName(), "sf");
  addInternalNode(symbol_table, li_BRA_sf_GND, getName(), "sf_GND_branch");

  if (loadLeadCurrent)
  {
    addBranchDataNode( symbol_table, li_branch_id, getName(), "BRANCH_DD");
    addBranchDataNode( symbol_table, li_branch_ig, getName(), "BRANCH_DG");
    addBranchDataNode( symbol_table, li_branch_is, getName(), "BRANCH_DS");
  }
}

//-----------------------------------------------------------------------------
// Function      : Instance::registerStoreLIDs
// Purpose       :
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
//-----------------------------------------------------------------------------
void Instance::registerStoreLIDs( const LocalIdVector & stoLIDVecRef)
{
  AssertLIDs(stoLIDVecRef.size() == getNumStoreVars());
}

//-----------------------------------------------------------------------------
// Function      : Instance::registerBranchDataLIDs
// Purpose       :
// Special Notes :
// Scope         : public
// Creator       : Eric Keiter, SNL
// Creation Date : 12/09/11
//-----------------------------------------------------------------------------
void Instance::registerBranchDataLIDs(const std::vector<int> & branchLIDVecRef)
{
  AssertLIDs(branchLIDVecRef.size() == getNumBranchDataVars());

  if (loadLeadCurrent)
  {
    int i = 0;
    li_branch_id = branchLIDVecRef[i++];
    li_branch_ig = branchLIDVecRef[i++];
    li_branch_is = branchLIDVecRef[i++];
  }
}

//-----------------------------------------------------------------------------
// Function      : Instance::jacobianStamp
// Purpose       :
// Special Notes : In initial version, we won't support mapping away nodes
// Scope         : public
// Creator       : admsXml
// Creation Date :
//-----------------------------------------------------------------------------
const JacobianStamp & Instance::jacobianStamp() const
{
  return jacStamp;
}

//-----------------------------------------------------------------------------
// Function      : Instance::registerJacLIDs
// Purpose       : Create Offset variables used for referencing jacobian
//                 elements
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
//-----------------------------------------------------------------------------
void Instance::registerJacLIDs( const JacobianStamp & jacLIDVec)
{
  DeviceInstance::registerJacLIDs(jacLIDVec);  IntPair jacLoc;
  jacLoc = pairToJacStampMap[IntPair(admsNodeID_d,admsNodeID_si)];
  A_d_Equ_si_NodeOffset = jacLIDVec[jacLoc.first][jacLoc.second];
  jacLoc = pairToJacStampMap[IntPair(admsNodeID_d,admsNodeID_sf)];
  A_d_Equ_sf_NodeOffset = jacLIDVec[jacLoc.first][jacLoc.second];
  jacLoc = pairToJacStampMap[IntPair(admsNodeID_d,admsNodeID_di)];
  A_d_Equ_di_NodeOffset = jacLIDVec[jacLoc.first][jacLoc.second];
  jacLoc = pairToJacStampMap[IntPair(admsNodeID_d,admsNodeID_d)];
  A_d_Equ_d_NodeOffset = jacLIDVec[jacLoc.first][jacLoc.second];
  jacLoc = pairToJacStampMap[IntPair(admsNodeID_s,admsNodeID_di)];
  A_s_Equ_di_NodeOffset = jacLIDVec[jacLoc.first][jacLoc.second];
  jacLoc = pairToJacStampMap[IntPair(admsNodeID_s,admsNodeID_sf)];
  A_s_Equ_sf_NodeOffset = jacLIDVec[jacLoc.first][jacLoc.second];
  jacLoc = pairToJacStampMap[IntPair(admsNodeID_s,admsNodeID_s)];
  A_s_Equ_s_NodeOffset = jacLIDVec[jacLoc.first][jacLoc.second];
  jacLoc = pairToJacStampMap[IntPair(admsNodeID_s,admsNodeID_si)];
  A_s_Equ_si_NodeOffset = jacLIDVec[jacLoc.first][jacLoc.second];
  jacLoc = pairToJacStampMap[IntPair(admsNodeID_di,admsNodeID_si)];
  A_di_Equ_si_NodeOffset = jacLIDVec[jacLoc.first][jacLoc.second];
  jacLoc = pairToJacStampMap[IntPair(admsNodeID_di,admsNodeID_di)];
  A_di_Equ_di_NodeOffset = jacLIDVec[jacLoc.first][jacLoc.second];
  jacLoc = pairToJacStampMap[IntPair(admsNodeID_di,admsNodeID_sf)];
  A_di_Equ_sf_NodeOffset = jacLIDVec[jacLoc.first][jacLoc.second];
  jacLoc = pairToJacStampMap[IntPair(admsNodeID_di,admsNodeID_d)];
  A_di_Equ_d_NodeOffset = jacLIDVec[jacLoc.first][jacLoc.second];
  jacLoc = pairToJacStampMap[IntPair(admsNodeID_si,admsNodeID_si)];
  A_si_Equ_si_NodeOffset = jacLIDVec[jacLoc.first][jacLoc.second];
  jacLoc = pairToJacStampMap[IntPair(admsNodeID_si,admsNodeID_di)];
  A_si_Equ_di_NodeOffset = jacLIDVec[jacLoc.first][jacLoc.second];
  jacLoc = pairToJacStampMap[IntPair(admsNodeID_si,admsNodeID_sf)];
  A_si_Equ_sf_NodeOffset = jacLIDVec[jacLoc.first][jacLoc.second];
  jacLoc = pairToJacStampMap[IntPair(admsNodeID_si,admsNodeID_s)];
  A_si_Equ_s_NodeOffset = jacLIDVec[jacLoc.first][jacLoc.second];
  jacLoc=pairToJacStampMap[IntPair(admsNodeID_sf,admsBRA_ID_sf_GND)];
  A_sf_Equ_BRA_sf_GND_Var_Offset = jacLIDVec[jacLoc.first][jacLoc.second];
  jacLoc = pairToJacStampMap[IntPair(admsBRA_ID_sf_GND,admsNodeID_sf)];
  A_BRA_sf_GND_Equ_sf_Node_Offset = jacLIDVec[jacLoc.first][jacLoc.second];
  jacLoc = pairToJacStampMap[IntPair(admsBRA_ID_sf_GND,admsNodeID_si)];
  A_BRA_sf_GND_Equ_si_Node_Offset = jacLIDVec[jacLoc.first][jacLoc.second];
  jacLoc = pairToJacStampMap[IntPair(admsBRA_ID_sf_GND,admsNodeID_g)];
  A_BRA_sf_GND_Equ_g_Node_Offset = jacLIDVec[jacLoc.first][jacLoc.second];
  jacLoc = pairToJacStampMap[IntPair(admsBRA_ID_sf_GND,admsNodeID_di)];
  A_BRA_sf_GND_Equ_di_Node_Offset = jacLIDVec[jacLoc.first][jacLoc.second];


}

//-----------------------------------------------------------------------------
// Function      : Instance::setupPointers
// Purpose       : Create pointer variables used for referencing jacobian
//                 elements
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
//-----------------------------------------------------------------------------
void Instance::setupPointers( )
{

  Linear::Matrix & dFdx = *(extData.dFdxMatrixPtr);
  Linear::Matrix & dQdx = *(extData.dQdxMatrixPtr);
  f_d_Equ_si_Node_Ptr = &(dFdx[li_d][A_d_Equ_si_NodeOffset]);
  q_d_Equ_si_Node_Ptr = &(dQdx[li_d][A_d_Equ_si_NodeOffset]);
  f_d_Equ_sf_Node_Ptr = &(dFdx[li_d][A_d_Equ_sf_NodeOffset]);
  q_d_Equ_sf_Node_Ptr = &(dQdx[li_d][A_d_Equ_sf_NodeOffset]);
  f_d_Equ_di_Node_Ptr = &(dFdx[li_d][A_d_Equ_di_NodeOffset]);
  q_d_Equ_di_Node_Ptr = &(dQdx[li_d][A_d_Equ_di_NodeOffset]);
  f_d_Equ_d_Node_Ptr = &(dFdx[li_d][A_d_Equ_d_NodeOffset]);
  q_d_Equ_d_Node_Ptr = &(dQdx[li_d][A_d_Equ_d_NodeOffset]);
  f_s_Equ_di_Node_Ptr = &(dFdx[li_s][A_s_Equ_di_NodeOffset]);
  q_s_Equ_di_Node_Ptr = &(dQdx[li_s][A_s_Equ_di_NodeOffset]);
  f_s_Equ_sf_Node_Ptr = &(dFdx[li_s][A_s_Equ_sf_NodeOffset]);
  q_s_Equ_sf_Node_Ptr = &(dQdx[li_s][A_s_Equ_sf_NodeOffset]);
  f_s_Equ_s_Node_Ptr = &(dFdx[li_s][A_s_Equ_s_NodeOffset]);
  q_s_Equ_s_Node_Ptr = &(dQdx[li_s][A_s_Equ_s_NodeOffset]);
  f_s_Equ_si_Node_Ptr = &(dFdx[li_s][A_s_Equ_si_NodeOffset]);
  q_s_Equ_si_Node_Ptr = &(dQdx[li_s][A_s_Equ_si_NodeOffset]);
  f_di_Equ_si_Node_Ptr = &(dFdx[li_di][A_di_Equ_si_NodeOffset]);
  q_di_Equ_si_Node_Ptr = &(dQdx[li_di][A_di_Equ_si_NodeOffset]);
  f_di_Equ_di_Node_Ptr = &(dFdx[li_di][A_di_Equ_di_NodeOffset]);
  q_di_Equ_di_Node_Ptr = &(dQdx[li_di][A_di_Equ_di_NodeOffset]);
  f_di_Equ_sf_Node_Ptr = &(dFdx[li_di][A_di_Equ_sf_NodeOffset]);
  q_di_Equ_sf_Node_Ptr = &(dQdx[li_di][A_di_Equ_sf_NodeOffset]);
  f_di_Equ_d_Node_Ptr = &(dFdx[li_di][A_di_Equ_d_NodeOffset]);
  q_di_Equ_d_Node_Ptr = &(dQdx[li_di][A_di_Equ_d_NodeOffset]);
  f_si_Equ_si_Node_Ptr = &(dFdx[li_si][A_si_Equ_si_NodeOffset]);
  q_si_Equ_si_Node_Ptr = &(dQdx[li_si][A_si_Equ_si_NodeOffset]);
  f_si_Equ_di_Node_Ptr = &(dFdx[li_si][A_si_Equ_di_NodeOffset]);
  q_si_Equ_di_Node_Ptr = &(dQdx[li_si][A_si_Equ_di_NodeOffset]);
  f_si_Equ_sf_Node_Ptr = &(dFdx[li_si][A_si_Equ_sf_NodeOffset]);
  q_si_Equ_sf_Node_Ptr = &(dQdx[li_si][A_si_Equ_sf_NodeOffset]);
  f_si_Equ_s_Node_Ptr = &(dFdx[li_si][A_si_Equ_s_NodeOffset]);
  q_si_Equ_s_Node_Ptr = &(dQdx[li_si][A_si_Equ_s_NodeOffset]);
  f_sf_Equ_BRA_sf_GND_Var_Ptr = &(dFdx[li_sf][A_sf_Equ_BRA_sf_GND_Var_Offset]);
  q_sf_Equ_BRA_sf_GND_Var_Ptr = &(dQdx[li_sf][A_sf_Equ_BRA_sf_GND_Var_Offset]);
  f_BRA_sf_GND_Equ_sf_Node_Ptr = &(dFdx[li_BRA_sf_GND][A_BRA_sf_GND_Equ_sf_Node_Offset]);
  q_BRA_sf_GND_Equ_sf_Node_Ptr =  &(dQdx[li_BRA_sf_GND][A_BRA_sf_GND_Equ_sf_Node_Offset]);
  f_BRA_sf_GND_Equ_si_Node_Ptr = &(dFdx[li_BRA_sf_GND][A_BRA_sf_GND_Equ_si_Node_Offset]);
  q_BRA_sf_GND_Equ_si_Node_Ptr =  &(dQdx[li_BRA_sf_GND][A_BRA_sf_GND_Equ_si_Node_Offset]);
  f_BRA_sf_GND_Equ_g_Node_Ptr = &(dFdx[li_BRA_sf_GND][A_BRA_sf_GND_Equ_g_Node_Offset]);
  q_BRA_sf_GND_Equ_g_Node_Ptr =  &(dQdx[li_BRA_sf_GND][A_BRA_sf_GND_Equ_g_Node_Offset]);
  f_BRA_sf_GND_Equ_di_Node_Ptr = &(dFdx[li_BRA_sf_GND][A_BRA_sf_GND_Equ_di_Node_Offset]);
  q_BRA_sf_GND_Equ_di_Node_Ptr =  &(dQdx[li_BRA_sf_GND][A_BRA_sf_GND_Equ_di_Node_Offset]);


}

// RHS load functions

//-----------------------------------------------------------------------------
// Function      : Instance::loadDAEFVector
// Purpose       : load F vector (static contributions) for one instance for
//                 NEW DAE formulation
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
//-----------------------------------------------------------------------------
bool Instance::loadDAEFVector()
{

  bool bsuccess=true;
  (*extData.daeFVectorPtr)[li_d] += staticContributions[admsNodeID_d];
  (*extData.daeFVectorPtr)[li_g] += staticContributions[admsNodeID_g];
  (*extData.daeFVectorPtr)[li_s] += staticContributions[admsNodeID_s];
  (*extData.daeFVectorPtr)[li_di] += staticContributions[admsNodeID_di];
  (*extData.daeFVectorPtr)[li_si] += staticContributions[admsNodeID_si];
  (*extData.daeFVectorPtr)[li_sf] += staticContributions[admsNodeID_sf];

  (*extData.daeFVectorPtr)[li_BRA_sf_GND] += staticContributions[admsBRA_ID_sf_GND];

  if (loadLeadCurrent)
  {
    double * leadF = extData.nextLeadCurrFCompRawPtr;

    leadF[li_branch_id] = leadCurrentF[admsNodeID_d];
    leadF[li_branch_ig] = leadCurrentF[admsNodeID_g];
    leadF[li_branch_is] = leadCurrentF[admsNodeID_s];

    // here we have to do special things for BJTs, MOSFETs and 2-terminal
    // devices for power computation.

    double * solVec = extData.nextSolVectorRawPtr;
    double * junctionV = extData.nextJunctionVCompRawPtr;
    junctionV[li_branch_id] = solVec[li_d] - solVec[li_s];
    junctionV[li_branch_ig] = solVec[li_g] - solVec[li_s];

  }
  return bsuccess;
}

//-----------------------------------------------------------------------------
// Function      : Instance::loadDAEQVector
// Purpose       : load Q vector (dynamic contributions) for one instance for
//                 NEW DAE formulation
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
//-----------------------------------------------------------------------------
bool Instance::loadDAEQVector()
{
  (*extData.daeQVectorPtr)[li_d] += dynamicContributions[admsNodeID_d];
  (*extData.daeQVectorPtr)[li_g] += dynamicContributions[admsNodeID_g];
  (*extData.daeQVectorPtr)[li_s] += dynamicContributions[admsNodeID_s];
  (*extData.daeQVectorPtr)[li_di] += dynamicContributions[admsNodeID_di];
  (*extData.daeQVectorPtr)[li_si] += dynamicContributions[admsNodeID_si];
  (*extData.daeQVectorPtr)[li_sf] += dynamicContributions[admsNodeID_sf];

  (*extData.daeQVectorPtr)[li_BRA_sf_GND] += dynamicContributions[admsBRA_ID_sf_GND];

  if (loadLeadCurrent)
  {
    double * leadQ = extData.nextLeadCurrQCompRawPtr;

    leadQ[li_branch_id] = leadCurrentQ[admsNodeID_d];
    leadQ[li_branch_ig] = leadCurrentQ[admsNodeID_g];
    leadQ[li_branch_is] = leadCurrentQ[admsNodeID_s];
  }
  return true;
}


//-----------------------------------------------------------------------------
// Function      : Instance::updatePrimaryState
// Purpose       :
// Special Notes : In this initial implementation, does little more than
//                 call updateIntermediateVars()
// Scope         : public
// Creator       : admsXml
// Creation Date :
//-----------------------------------------------------------------------------
bool Instance::updatePrimaryState()
{
  bool bsuccess = true;

  bsuccess = updateIntermediateVars();

  // if old DAE were implemented, we'd save dynamic contributions as state
  // here.


  return bsuccess;
}

//-----------------------------------------------------------------------------
// Function      : Instance::updateSecondaryState
// Purpose       :
// Special Notes : In this initial implementation, does nothing
// Scope         : public
// Creator       : admsXml
// Creation Date :
//-----------------------------------------------------------------------------
bool Instance::updateSecondaryState()
{
  bool bsuccess = true;

  // were old DAE implemented, we'd pull dynamic contribution derivatives
  // out of state.

  return bsuccess;
}

//-----------------------------------------------------------------------------
// Function      : Instance::updateIntermediateVars
// Purpose       : update intermediate variables for one mvs_2_0_0_hemt instance
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
//-----------------------------------------------------------------------------
bool Instance::updateIntermediateVars()
{

  bool bsuccess=true;
  Linear::Vector * solVectorPtr = extData.nextSolVectorPtr;

  if (DEBUG_DEVICE && isActive(Diag::DEVICE_PARAMETERS) && getSolverState().debugTimeFlag)
  {
    Xyce::dout() << std::endl << subsection_divider << std::endl;
    Xyce::dout() << "  In ADMSmvs_2_0_0_hemt::Instance::updateIntermediateVars\n\n";
    Xyce::dout() << "  name = " << getName() << std::endl;
  }

  // Local variables
  double Rd;
  double d_Rd_dV_sf_GND;
  double d_Rd_dV_di_GND;
  double d_Rd_dV_si_GND;
  double Rs;
  double d_Rs_dV_sf_GND;
  double d_Rs_dV_di_GND;
  double d_Rs_dV_si_GND;
  double Idsatbeta;
  double d_Idsatbeta_dV_sf_GND;
  double d_Idsatbeta_dV_di_GND;
  double d_Idsatbeta_dV_si_GND;
  double Id_sat;
  double Qacc;
  double Id;
  double d_Id_dV_sf_GND;
  double d_Id_dV_di_GND;
  double d_Id_dV_si_GND;
  double vx0;
  double d_vx0_dV_sf_GND;
  double Fsat;
  double d_Fsat_dV_di_GND;
  double d_Fsat_dV_si_GND;
  double d_Fsat_dV_sf_GND;
  double Vdsatbeta;
  double d_Vdsatbeta_dV_di_GND;
  double d_Vdsatbeta_dV_si_GND;
  double d_Vdsatbeta_dV_sf_GND;
  double Vdsat;
  double d_Vdsat_dV_sf_GND;
  double d_Vdsat_dV_di_GND;
  double d_Vdsat_dV_si_GND;
  double f1;
  double d_f1_dV_sf_GND;
  double d_f1_dV_di_GND;
  double d_f1_dV_si_GND;
  double n;
  double d_n_dV_di_GND;
  double d_n_dV_si_GND;
  double Cgc;
  double d_Cgc_dV_sf_GND;
  double d_Cgc_dV_di_GND;
  double d_Cgc_dV_si_GND;
  double Cstern;
  double d_Cstern_dV_sf_GND;
  double d_Cstern_dV_di_GND;
  double d_Cstern_dV_si_GND;
  double xav;
  double d_xav_dV_sf_GND;
  double d_xav_dV_di_GND;
  double d_xav_dV_si_GND;
  double QB;
  double Qx0;
  double d_Qx0_dV_sf_GND;
  double d_Qx0_dV_di_GND;
  double d_Qx0_dV_si_GND;
  double Tx;
  double d_Tx_dV_sf_GND;
  double d_Tx_dV_di_GND;
  double d_Tx_dV_si_GND;
  double Lcrit;
  double d_Lcrit_dV_di_GND;
  double d_Lcrit_dV_si_GND;
  double Lcrit_sat;
  double Lcrit_lin;
  double f2;
  double d_f2_dV_di_GND;
  double d_f2_dV_si_GND;
  double Vdsatbeta2;
  double d_Vdsatbeta2_dV_di_GND;
  double d_Vdsatbeta2_dV_si_GND;
  double Vdsat2;
  double vT_acc;
  double extr_coef_acc;
  double FDhalfs_acc;
  double c1_acc;
  double den1_acc;
  double A1_acc;
  double expMeta_acc;
  double expu_acc;
  double exp_eta_acc;
  double eta_acc;
  double vT;
  double d_vT_dV_sf_GND;
  double lambda;
  double d_lambda_dV_sf_GND;
  double dgen_lambda;
  double d_dgen_lambda_dV_sf_GND;
  double FDminushalfs;
  double d_FDminushalfs_dV_sf_GND;
  double t2_fd1;
  double d_t2_fd1_dV_sf_GND;
  double den_t1_fd1;
  double d_den_t1_fd1_dV_sf_GND;
  double aterm1;
  double d_aterm1_dV_sf_GND;
  double num_t1_fd1;
  double c_pow1;
  double b_pow1;
  double a_pow1;
  double j_pow1;
  double u1;
  double d_u1_dV_sf_GND;
  double extr_coef;
  double d_extr_coef_dV_sf_GND;
  double FDhalfs;
  double d_FDhalfs_dV_sf_GND;
  double c1;
  double d_c1_dV_sf_GND;
  double den1;
  double d_den1_dV_sf_GND;
  double A1;
  double d_A1_dV_sf_GND;
  double expMeta;
  double d_expMeta_dV_sf_GND;
  double NP_fac_velocity;
  double d_NP_fac_velocity_dV_sf_GND;
  double NP_fac_lambda;
  double d_NP_fac_lambda_dV_sf_GND;
  double meff_np;
  double d_meff_np_dV_sf_GND;
  double Fd;
  double d_Fd_dV_sf_GND;
  double d_Fd_dV_di_GND;
  double d_Fd_dV_si_GND;
  double Ed_sq;
  double d_Ed_sq_dV_sf_GND;
  double d_Ed_sq_dV_di_GND;
  double d_Ed_sq_dV_si_GND;
  double ffd;
  double d_ffd_dV_sf_GND;
  double d_ffd_dV_di_GND;
  double d_ffd_dV_si_GND;
  double expEd;
  double d_expEd_dV_sf_GND;
  double d_expEd_dV_di_GND;
  double d_expEd_dV_si_GND;
  double sign_Ed;
  double Ed;
  double d_Ed_dV_sf_GND;
  double d_Ed_dV_di_GND;
  double d_Ed_dV_si_GND;
  double Fs;
  double d_Fs_dV_sf_GND;
  double Es_sq;
  double d_Es_sq_dV_sf_GND;
  double ffs;
  double d_ffs_dV_sf_GND;
  double expEs;
  double d_expEs_dV_sf_GND;
  double sign_Es;
  double Es;
  double d_Es_dV_sf_GND;
  double N2D;
  double lambda_int;
  double vT_int;
  double mD0;
  double sqrt_pi;
  double hbar;
  double kT;
  double phit;
  double Rc;
  double Leff;
  double dir;
  double Vgsi;
  double d_Vgsi_dV_di_GND;
  double d_Vgsi_dV_g_GND;
  double d_Vgsi_dV_si_GND;
  double Vdsi;
  double d_Vdsi_dV_di_GND;
  double d_Vdsi_dV_si_GND;
  double Vgs;
  double d_Vgs_dV_d_GND;
  double d_Vgs_dV_g_GND;
  double d_Vgs_dV_s_GND;
  double Vds;
  double d_Vds_dV_d_GND;
  double d_Vds_dV_s_GND;
  double Vgdraw;
  double d_Vgdraw_dV_g_GND;
  double d_Vgdraw_dV_di_GND;
  double Vgsraw;
  double d_Vgsraw_dV_g_GND;
  double d_Vgsraw_dV_si_GND;


  // set the sizes of the Fad arrays:

  if (probeVars.size() != (7))
  {
    probeVars.resize(7);
    d_probeVars.resize(7);
    for (int i=0;i<7;i++)
    {
      d_probeVars[i].resize(7);
      for (int j=0;j<7;j++)
        d_probeVars[i][j]=0.0;
    }
    staticContributions.resize(6+1);
    d_staticContributions.resize(6+1);
    for (int i=0;i<6+1;i++)
      d_staticContributions[i].resize(7);
    dynamicContributions.resize(6+1);
    d_dynamicContributions.resize(6+1);
    for (int i=0;i<6+1;i++)
      d_dynamicContributions[i].resize(7);
  }


  // initialize contributions to zero (automatically sets derivatives to zero)
  for (int i=0; i < 6+1 ; ++i)
  {
    staticContributions[i]=0;
    for (int j=0;j<7;j++)
      d_staticContributions[i][j] = 0.0;
    dynamicContributions[i]=0;
    for (int j=0;j<7;j++)
      d_dynamicContributions[i][j] = 0.0;
  }

  // extract solution variables and set as Fad independent variables.
  probeVars[admsProbeID_V_sf_GND] = (*solVectorPtr)[li_sf];
  d_probeVars[admsProbeID_V_sf_GND][admsProbeID_V_sf_GND] = 1.0;
  probeVars[admsProbeID_V_s_GND] = (*solVectorPtr)[li_s];
  d_probeVars[admsProbeID_V_s_GND][admsProbeID_V_s_GND] = 1.0;
  probeVars[admsProbeID_V_d_GND] = (*solVectorPtr)[li_d];
  d_probeVars[admsProbeID_V_d_GND][admsProbeID_V_d_GND] = 1.0;
  probeVars[admsProbeID_V_di_GND] = (*solVectorPtr)[li_di];
  d_probeVars[admsProbeID_V_di_GND][admsProbeID_V_di_GND] = 1.0;
  probeVars[admsProbeID_V_si_GND] = (*solVectorPtr)[li_si];
  d_probeVars[admsProbeID_V_si_GND][admsProbeID_V_si_GND] = 1.0;
  probeVars[admsProbeID_V_g_GND] = (*solVectorPtr)[li_g];
  d_probeVars[admsProbeID_V_g_GND][admsProbeID_V_g_GND] = 1.0;
  probeVars[admsProbeID_I_sf_GND] = (*solVectorPtr)[li_BRA_sf_GND];
  d_probeVars[admsProbeID_I_sf_GND][admsProbeID_I_sf_GND] = 1.0;
  // -- code converted from analog/code block

  d_Vgsraw_dV_si_GND = ((model_.type)*(-d_probeVars[admsProbeID_V_si_GND][admsProbeID_V_si_GND]));
  d_Vgsraw_dV_g_GND = ((model_.type)*d_probeVars[admsProbeID_V_g_GND][admsProbeID_V_g_GND]);
  Vgsraw = ((model_.type)*((probeVars[admsProbeID_V_g_GND])-(probeVars[admsProbeID_V_si_GND])));

  d_Vgdraw_dV_di_GND = ((model_.type)*(-d_probeVars[admsProbeID_V_di_GND][admsProbeID_V_di_GND]));
  d_Vgdraw_dV_g_GND = ((model_.type)*d_probeVars[admsProbeID_V_g_GND][admsProbeID_V_g_GND]);
  Vgdraw = ((model_.type)*((probeVars[admsProbeID_V_g_GND])-(probeVars[admsProbeID_V_di_GND])));
  if ((Vgsraw>=Vgdraw))
  {

    d_Vds_dV_s_GND = ((model_.type)*(-d_probeVars[admsProbeID_V_s_GND][admsProbeID_V_s_GND]));
    d_Vds_dV_d_GND = ((model_.type)*d_probeVars[admsProbeID_V_d_GND][admsProbeID_V_d_GND]);
    Vds = ((model_.type)*((probeVars[admsProbeID_V_d_GND])-(probeVars[admsProbeID_V_s_GND])));

    d_Vgs_dV_d_GND =  0.0;
    d_Vgs_dV_s_GND = ((model_.type)*(-d_probeVars[admsProbeID_V_s_GND][admsProbeID_V_s_GND]));
    d_Vgs_dV_g_GND = ((model_.type)*d_probeVars[admsProbeID_V_g_GND][admsProbeID_V_g_GND]);
    Vgs = ((model_.type)*((probeVars[admsProbeID_V_g_GND])-(probeVars[admsProbeID_V_s_GND])));

    d_Vdsi_dV_si_GND = ((model_.type)*(-d_probeVars[admsProbeID_V_si_GND][admsProbeID_V_si_GND]));
    d_Vdsi_dV_di_GND = ((model_.type)*d_probeVars[admsProbeID_V_di_GND][admsProbeID_V_di_GND]);
    Vdsi = ((model_.type)*((probeVars[admsProbeID_V_di_GND])-(probeVars[admsProbeID_V_si_GND])));

    d_Vgsi_dV_di_GND =  0.0;
    d_Vgsi_dV_si_GND = d_Vgsraw_dV_si_GND;
    d_Vgsi_dV_g_GND = d_Vgsraw_dV_g_GND;
    Vgsi = Vgsraw;
    dir = 1;
  }
  else
  {

    d_Vds_dV_d_GND = ((model_.type)*(-d_probeVars[admsProbeID_V_d_GND][admsProbeID_V_d_GND]));
    d_Vds_dV_s_GND = ((model_.type)*d_probeVars[admsProbeID_V_s_GND][admsProbeID_V_s_GND]);
    Vds = ((model_.type)*((probeVars[admsProbeID_V_s_GND])-(probeVars[admsProbeID_V_d_GND])));

    d_Vgs_dV_s_GND =  0.0;
    d_Vgs_dV_d_GND = ((model_.type)*(-d_probeVars[admsProbeID_V_d_GND][admsProbeID_V_d_GND]));
    d_Vgs_dV_g_GND = ((model_.type)*d_probeVars[admsProbeID_V_g_GND][admsProbeID_V_g_GND]);
    Vgs = ((model_.type)*((probeVars[admsProbeID_V_g_GND])-(probeVars[admsProbeID_V_d_GND])));

    d_Vdsi_dV_di_GND = ((model_.type)*(-d_probeVars[admsProbeID_V_di_GND][admsProbeID_V_di_GND]));
    d_Vdsi_dV_si_GND = ((model_.type)*d_probeVars[admsProbeID_V_si_GND][admsProbeID_V_si_GND]);
    Vdsi = ((model_.type)*((probeVars[admsProbeID_V_si_GND])-(probeVars[admsProbeID_V_di_GND])));

    d_Vgsi_dV_si_GND =  0.0;
    d_Vgsi_dV_di_GND = d_Vgdraw_dV_di_GND;
    d_Vgsi_dV_g_GND = d_Vgdraw_dV_g_GND;
    Vgsi = Vgdraw;
    dir = (-1);
  }
  Leff = ((model_.Lgdr)-(model_.dLg));
  Rc = ((model_.Rc0)/(model_.W));
  phit = ((1.3806503e-23*(model_.Tjun))/1.6021766208e-19);
  kT = (1.3806503e-23*(model_.Tjun));
  hbar = (6.62607004081e-34/(2.0*3.14159265358979323846));
  {
    double value_sqrt_0 = sqrt(static_cast<double>(3.14159265358979323846));
    sqrt_pi = value_sqrt_0;
  }
  mD0 = ((model_.meff)*9.10938215e-31);
  {
    double value_sqrt_0 = sqrt(((((2.0*kT)/3.14159265358979323846)*1.0)/mD0));
    vT_int = value_sqrt_0;
  }
  lambda_int = (((2.0*phit)*(model_.mu_eff))/vT_int);
  N2D = ((mD0/((3.14159265358979323846*hbar)*hbar))*kT);

  d_Es_dV_sf_GND = (d_probeVars[admsProbeID_V_sf_GND][admsProbeID_V_sf_GND]/phit);
  Es = (((model_.energy_diff_volt)+(probeVars[admsProbeID_V_sf_GND]))/phit);
  if ((Es>0))
  {
    sign_Es = 1.0;
  }
  else
  {
    if ((Es==0))
    {
      sign_Es = 0;
    }
    else
    {
      if ((Es<0))
      {
        sign_Es = (-1.0);
      }
    }
  }
  {
    double value_exp_0 = exp(Es);
    double  deriv_exp_0_d0 = value_exp_0;

    d_expEs_dV_sf_GND = (deriv_exp_0_d0*(d_Es_dV_sf_GND));
    expEs = value_exp_0;
  }
  if ((Es>=40))
  {

    d_ffs_dV_sf_GND =  0.0;
    ffs = 0;
  }
  else
  {

    d_ffs_dV_sf_GND = (-(d_expEs_dV_sf_GND*0.6)/(1.0+(expEs*0.6))/(1.0+(expEs*0.6)));
    ffs = (1.0/(1.0+(expEs*0.6)));
  }

  d_Es_sq_dV_sf_GND = (((((1.0+sign_Es)*Es)*d_Es_dV_sf_GND)+(((1.0+sign_Es)*d_Es_dV_sf_GND)*Es))/4.0);
  Es_sq = ((((1.0+sign_Es)*Es)*Es)/4.0);
  {
    double value_log_0 = log((1.0+expEs));
    double  deriv_log_0_d0 = (1.0/(1.0+expEs));

    d_Fs_dV_sf_GND = ((deriv_log_0_d0*(d_expEs_dV_sf_GND))+(((model_.np_mass)*phit)*(((ffs*d_expEs_dV_sf_GND)+(d_ffs_dV_sf_GND*expEs))+(((1-ffs)*d_Es_sq_dV_sf_GND)+((-d_ffs_dV_sf_GND)*Es_sq)))));
    Fs = (value_log_0+(((model_.np_mass)*phit)*((ffs*expEs)+((1-ffs)*Es_sq))));
  }

  d_Ed_dV_si_GND = ((-d_Vdsi_dV_si_GND)/phit);
  d_Ed_dV_di_GND = ((-d_Vdsi_dV_di_GND)/phit);
  d_Ed_dV_sf_GND = (d_probeVars[admsProbeID_V_sf_GND][admsProbeID_V_sf_GND]/phit);
  Ed = ((((model_.energy_diff_volt)+(probeVars[admsProbeID_V_sf_GND]))-Vdsi)/phit);
  if ((Ed>0))
  {
    sign_Ed = 1.0;
  }
  else
  {
    if ((Ed==0))
    {
      sign_Ed = 0;
    }
    else
    {
      if ((Ed<0))
      {
        sign_Ed = (-1.0);
      }
    }
  }
  {
    double value_exp_0 = exp(Ed);
    double  deriv_exp_0_d0 = value_exp_0;

    d_expEd_dV_si_GND = (deriv_exp_0_d0*(d_Ed_dV_si_GND));
    d_expEd_dV_di_GND = (deriv_exp_0_d0*(d_Ed_dV_di_GND));
    d_expEd_dV_sf_GND = (deriv_exp_0_d0*(d_Ed_dV_sf_GND));
    expEd = value_exp_0;
  }
  if ((Ed>=40))
  {

    d_ffd_dV_sf_GND = d_ffd_dV_di_GND = d_ffd_dV_si_GND =  0.0;
    ffd = 0;
  }
  else
  {

    d_ffd_dV_si_GND = (-(d_expEd_dV_si_GND*0.6)/(1.0+(expEd*0.6))/(1.0+(expEd*0.6)));
    d_ffd_dV_di_GND = (-(d_expEd_dV_di_GND*0.6)/(1.0+(expEd*0.6))/(1.0+(expEd*0.6)));
    d_ffd_dV_sf_GND = (-(d_expEd_dV_sf_GND*0.6)/(1.0+(expEd*0.6))/(1.0+(expEd*0.6)));
    ffd = (1.0/(1.0+(expEd*0.6)));
  }

  d_Ed_sq_dV_si_GND = (((((1.0+sign_Ed)*Ed)*d_Ed_dV_si_GND)+(((1.0+sign_Ed)*d_Ed_dV_si_GND)*Ed))/4.0);
  d_Ed_sq_dV_di_GND = (((((1.0+sign_Ed)*Ed)*d_Ed_dV_di_GND)+(((1.0+sign_Ed)*d_Ed_dV_di_GND)*Ed))/4.0);
  d_Ed_sq_dV_sf_GND = (((((1.0+sign_Ed)*Ed)*d_Ed_dV_sf_GND)+(((1.0+sign_Ed)*d_Ed_dV_sf_GND)*Ed))/4.0);
  Ed_sq = ((((1.0+sign_Ed)*Ed)*Ed)/4.0);
  {
    double value_log_0 = log((1.0+expEd));
    double  deriv_log_0_d0 = (1.0/(1.0+expEd));

    d_Fd_dV_si_GND = ((deriv_log_0_d0*(d_expEd_dV_si_GND))+(((model_.np_mass)*phit)*(((ffd*d_expEd_dV_si_GND)+(d_ffd_dV_si_GND*expEd))+(((1.0-ffd)*d_Ed_sq_dV_si_GND)+((-d_ffd_dV_si_GND)*Ed_sq)))));
    d_Fd_dV_di_GND = ((deriv_log_0_d0*(d_expEd_dV_di_GND))+(((model_.np_mass)*phit)*(((ffd*d_expEd_dV_di_GND)+(d_ffd_dV_di_GND*expEd))+(((1.0-ffd)*d_Ed_sq_dV_di_GND)+((-d_ffd_dV_di_GND)*Ed_sq)))));
    d_Fd_dV_sf_GND = ((deriv_log_0_d0*(d_expEd_dV_sf_GND))+(((model_.np_mass)*phit)*(((ffd*d_expEd_dV_sf_GND)+(d_ffd_dV_sf_GND*expEd))+(((1.0-ffd)*d_Ed_sq_dV_sf_GND)+((-d_ffd_dV_sf_GND)*Ed_sq)))));
    Fd = (value_log_0+(((model_.np_mass)*phit)*((ffd*expEd)+((1.0-ffd)*Ed_sq))));
  }
  if ((Es>=40))
  {

    d_meff_np_dV_sf_GND = ((expEs*d_Fs_dV_sf_GND-Fs*d_expEs_dV_sf_GND)/expEs/expEs);
    meff_np = (Fs/expEs);
  }
  else
  {
    {
      double value_log_0 = log((1.0+expEs));
      double  deriv_log_0_d0 = (1.0/(1.0+expEs));

      d_meff_np_dV_sf_GND = ((value_log_0*d_Fs_dV_sf_GND-Fs*(deriv_log_0_d0*(d_expEs_dV_sf_GND)))/value_log_0/value_log_0);
      meff_np = (Fs/value_log_0);
    }
  }
  {
    double value_sqrt_0 = sqrt(meff_np);
    double  deriv_sqrt_0_d0 = (0.5/value_sqrt_0);

    d_NP_fac_lambda_dV_sf_GND = (deriv_sqrt_0_d0*(d_meff_np_dV_sf_GND));
    NP_fac_lambda = value_sqrt_0;
  }

  d_NP_fac_velocity_dV_sf_GND = (-d_NP_fac_lambda_dV_sf_GND/NP_fac_lambda/NP_fac_lambda);
  NP_fac_velocity = (1.0/NP_fac_lambda);

  d_expMeta_dV_sf_GND = (-d_expEs_dV_sf_GND/expEs/expEs);
  expMeta = (1.0/expEs);
  {
    double value_pow_0 = pow(Es,4.0);
    double value_exp_1 = exp((((-0.17)*(1.0+Es))*(1.0+Es)));
    double  deriv_pow_0_d0 = ((Es == 0.0)?0.0:(value_pow_0*4.0/Es));
    double  deriv_exp_1_d0 = value_exp_1;

    d_A1_dV_sf_GND = ((deriv_pow_0_d0*(d_Es_dV_sf_GND))+(((33.6*Es)*(-(0.68*(deriv_exp_1_d0*(((((-0.17)*(1.0+Es))*d_Es_dV_sf_GND)+(((-0.17)*d_Es_dV_sf_GND)*(1.0+Es))))))))+((33.6*d_Es_dV_sf_GND)*(1-(0.68*value_exp_1)))));
    A1 = ((50.0+value_pow_0)+((33.6*Es)*(1-(0.68*value_exp_1))));
  }
  {
    double value_pow_0 = pow(A1,(3.0/8.0));
    double  deriv_pow_0_d0 = ((A1 == 0.0)?0.0:(value_pow_0*(3.0/8.0)/A1));

    d_den1_dV_sf_GND = (deriv_pow_0_d0*(d_A1_dV_sf_GND));
    den1 = value_pow_0;
  }

  d_c1_dV_sf_GND = (-((3.0/4.0)*sqrt_pi)*d_den1_dV_sf_GND/den1/den1);
  c1 = (((3.0/4.0)*sqrt_pi)/den1);

  d_FDhalfs_dV_sf_GND = (-(d_c1_dV_sf_GND+d_expMeta_dV_sf_GND)/(c1+expMeta)/(c1+expMeta));
  FDhalfs = (1.0/(c1+expMeta));
  {
    double value_log_0 = log((1.0+expEs));
    double  deriv_log_0_d0 = (1.0/(1.0+expEs));

    d_extr_coef_dV_sf_GND = ((value_log_0*d_FDhalfs_dV_sf_GND-FDhalfs*(deriv_log_0_d0*(d_expEs_dV_sf_GND)))/value_log_0/value_log_0);
    extr_coef = (FDhalfs/value_log_0);
  }

  d_u1_dV_sf_GND = d_Es_dV_sf_GND;
  u1 = Es;
  j_pow1 = (-0.5);
  {
    double value_sqrt_0 = sqrt(((1.0+((15.0/4.0)*(j_pow1+1.0)))+(((1.0/40.0)*(j_pow1+1.0))*(j_pow1+1.0))));
    a_pow1 = value_sqrt_0;
  }
  b_pow1 = (1.8+(0.61*j_pow1));
  {
    double value_sqrt_0 = sqrt(static_cast<double>(2.0));
    double value_pow_1 = pow(2.0,(-j_pow1));
    c_pow1 = (2.0+((2.0-value_sqrt_0)*value_pow_1));
  }
  {
    double value_pow_0 = pow(2.0,(1.0+j_pow1));
    num_t1_fd1 = ((j_pow1+1.0)*value_pow_0);
  }
  {
    double value_pow_0 = pow(a_pow1,c_pow1);
    double value_fabs_1 = fabs((u1-b_pow1));
    double value_pow_2 = pow(value_fabs_1,c_pow1);
    double value_pow_3 = pow((((b_pow1+u1)+value_pow_0)+value_pow_2),(1.0/c_pow1));
    double  deriv_fabs_1_d0 = ((((u1-b_pow1))>=0)?(+1.0):(-1.0));
    double  deriv_pow_2_d0 = ((value_fabs_1 == 0.0)?0.0:(value_pow_2*c_pow1/value_fabs_1));
    double  deriv_pow_3_d0 = (((((b_pow1+u1)+value_pow_0)+value_pow_2) == 0.0)?0.0:(value_pow_3*(1.0/c_pow1)/(((b_pow1+u1)+value_pow_0)+value_pow_2)));

    d_aterm1_dV_sf_GND = (deriv_pow_3_d0*((d_u1_dV_sf_GND+(deriv_pow_2_d0*((deriv_fabs_1_d0*(d_u1_dV_sf_GND)))))));
    aterm1 = value_pow_3;
  }
  {
    double value_pow_0 = pow(aterm1,(1.0+j_pow1));
    double  deriv_pow_0_d0 = ((aterm1 == 0.0)?0.0:(value_pow_0*(1.0+j_pow1)/aterm1));

    d_den_t1_fd1_dV_sf_GND = (deriv_pow_0_d0*(d_aterm1_dV_sf_GND));
    den_t1_fd1 = value_pow_0;
  }
  {
    double value_exp_0 = exp((-u1));
    double value_sqrt_1 = sqrt(static_cast<double>(3.14159265358979323846));
    double  deriv_exp_0_d0 = value_exp_0;

    d_t2_fd1_dV_sf_GND = ((deriv_exp_0_d0*((-d_u1_dV_sf_GND)))/value_sqrt_1);
    t2_fd1 = (value_exp_0/value_sqrt_1);
  }
  {
    double value_sqrt_0 = sqrt(static_cast<double>(3.14159265358979323846));
    double value_pow_1 = pow(((num_t1_fd1/den_t1_fd1)+t2_fd1),(-1.0));
    double  deriv_pow_1_d0 = ((((num_t1_fd1/den_t1_fd1)+t2_fd1) == 0.0)?0.0:(value_pow_1*(-1.0)/((num_t1_fd1/den_t1_fd1)+t2_fd1)));

    d_FDminushalfs_dV_sf_GND = ((1.0/value_sqrt_0)*(deriv_pow_1_d0*(((-num_t1_fd1*d_den_t1_fd1_dV_sf_GND/den_t1_fd1/den_t1_fd1)+d_t2_fd1_dV_sf_GND))));
    FDminushalfs = ((1.0/value_sqrt_0)*value_pow_1);
  }
  {
    double value_log_0 = log((1.0+expEs));
    double  deriv_log_0_d0 = (1.0/(1.0+expEs));

    d_dgen_lambda_dV_sf_GND = ((FDminushalfs*(deriv_log_0_d0*(d_expEs_dV_sf_GND))-value_log_0*d_FDminushalfs_dV_sf_GND)/FDminushalfs/FDminushalfs);
    dgen_lambda = (value_log_0/FDminushalfs);
  }

  d_lambda_dV_sf_GND = (((lambda_int*NP_fac_lambda)*d_dgen_lambda_dV_sf_GND)+((lambda_int*d_NP_fac_lambda_dV_sf_GND)*dgen_lambda));
  lambda = ((lambda_int*NP_fac_lambda)*dgen_lambda);

  d_vT_dV_sf_GND = (((vT_int*NP_fac_velocity)*d_extr_coef_dV_sf_GND)+((vT_int*d_NP_fac_velocity_dV_sf_GND)*extr_coef));
  vT = ((vT_int*NP_fac_velocity)*extr_coef);
  {
    double value_exp_0 = exp(((model_.nacc)/N2D));
    double value_log_1 = log((value_exp_0-1.0));
    eta_acc = value_log_1;
  }
  {
    double value_exp_0 = exp(((model_.nacc)/N2D));
    exp_eta_acc = (value_exp_0-1.0);
  }
  expu_acc = exp_eta_acc;
  expMeta_acc = (1.0/expu_acc);
  {
    double value_pow_0 = pow(eta_acc,4.0);
    double value_exp_1 = exp((((-0.17)*(1.0+eta_acc))*(1.0+eta_acc)));
    A1_acc = ((50.0+value_pow_0)+((33.6*eta_acc)*(1-(0.68*value_exp_1))));
  }
  {
    double value_pow_0 = pow(A1_acc,(3.0/8.0));
    den1_acc = value_pow_0;
  }
  c1_acc = (((3.0/4.0)*sqrt_pi)/den1_acc);
  FDhalfs_acc = (1.0/(c1_acc+expMeta_acc));
  {
    double value_log_0 = log((1.0+exp_eta_acc));
    extr_coef_acc = (FDhalfs_acc/value_log_0);
  }
  vT_acc = (vT_int*extr_coef_acc);
  Vdsat2 = ((model_.theta)*phit);
  {
    double value_fabs_0 = fabs((Vdsi/Vdsat2));
    double value_pow_1 = pow(value_fabs_0,(model_.beta));
    double  deriv_fabs_0_d0 = ((((Vdsi/Vdsat2))>=0)?(+1.0):(-1.0));
    double  deriv_pow_1_d0 = ((value_fabs_0 == 0.0)?0.0:(value_pow_1*(model_.beta)/value_fabs_0));

    d_Vdsatbeta2_dV_si_GND = (deriv_pow_1_d0*((deriv_fabs_0_d0*((d_Vdsi_dV_si_GND/Vdsat2)))));
    d_Vdsatbeta2_dV_di_GND = (deriv_pow_1_d0*((deriv_fabs_0_d0*((d_Vdsi_dV_di_GND/Vdsat2)))));
    Vdsatbeta2 = value_pow_1;
  }
  {
    double value_fabs_0 = fabs((Vdsi/Vdsat2));
    double value_pow_1 = pow((1.0+Vdsatbeta2),(1.0/(model_.beta)));
    double  deriv_fabs_0_d0 = ((((Vdsi/Vdsat2))>=0)?(+1.0):(-1.0));
    double  deriv_pow_1_d0 = (((1.0+Vdsatbeta2) == 0.0)?0.0:(value_pow_1*(1.0/(model_.beta))/(1.0+Vdsatbeta2)));

    d_f2_dV_si_GND = ((value_pow_1*(deriv_fabs_0_d0*((d_Vdsi_dV_si_GND/Vdsat2)))-value_fabs_0*(deriv_pow_1_d0*(d_Vdsatbeta2_dV_si_GND)))/value_pow_1/value_pow_1);
    d_f2_dV_di_GND = ((value_pow_1*(deriv_fabs_0_d0*((d_Vdsi_dV_di_GND/Vdsat2)))-value_fabs_0*(deriv_pow_1_d0*(d_Vdsatbeta2_dV_di_GND)))/value_pow_1/value_pow_1);
    f2 = (value_fabs_0/value_pow_1);
  }
  Lcrit_lin = Leff;
  Lcrit_sat = ((model_.ksee)*Leff);

  d_Lcrit_dV_si_GND = (((-d_f2_dV_si_GND)*Lcrit_lin)+(d_f2_dV_si_GND*Lcrit_sat));
  d_Lcrit_dV_di_GND = (((-d_f2_dV_di_GND)*Lcrit_lin)+(d_f2_dV_di_GND*Lcrit_sat));
  Lcrit = (((1.0-f2)*Lcrit_lin)+(f2*Lcrit_sat));

  d_Tx_dV_si_GND = (-lambda*d_Lcrit_dV_si_GND/(lambda+Lcrit)/(lambda+Lcrit));
  d_Tx_dV_di_GND = (-lambda*d_Lcrit_dV_di_GND/(lambda+Lcrit)/(lambda+Lcrit));
  d_Tx_dV_sf_GND = (((lambda+Lcrit)*d_lambda_dV_sf_GND-lambda*d_lambda_dV_sf_GND)/(lambda+Lcrit)/(lambda+Lcrit));
  Tx = (lambda/(lambda+Lcrit));

  d_Qx0_dV_si_GND = ((((-1.6021766208e-19)*N2D)/2.0)*((Fs*(-d_Tx_dV_si_GND))+((Fd*d_Tx_dV_si_GND)+(d_Fd_dV_si_GND*Tx))));
  d_Qx0_dV_di_GND = ((((-1.6021766208e-19)*N2D)/2.0)*((Fs*(-d_Tx_dV_di_GND))+((Fd*d_Tx_dV_di_GND)+(d_Fd_dV_di_GND*Tx))));
  d_Qx0_dV_sf_GND = ((((-1.6021766208e-19)*N2D)/2.0)*(((Fs*(-d_Tx_dV_sf_GND))+(d_Fs_dV_sf_GND*(2.0-Tx)))+((Fd*d_Tx_dV_sf_GND)+(d_Fd_dV_sf_GND*Tx))));
  Qx0 = ((((-1.6021766208e-19)*N2D)/2.0)*((Fs*(2.0-Tx))+(Fd*Tx)));
  {
    double value_fabs_0 = fabs(((model_.B)/(model_.dqm0)));
    double value_pow_1 = pow(value_fabs_0,3.0);
    QB = value_pow_1;
  }
  {
    double value_fabs_0 = fabs(Qx0);
    double value_pow_1 = pow((QB+((11.0/32.0)*value_fabs_0)),(1/3.0));
    double  deriv_fabs_0_d0 = (((Qx0)>=0)?(+1.0):(-1.0));
    double  deriv_pow_1_d0 = (((QB+((11.0/32.0)*value_fabs_0)) == 0.0)?0.0:(value_pow_1*(1/3.0)/(QB+((11.0/32.0)*value_fabs_0))));

    d_xav_dV_si_GND = (-(model_.B)*(deriv_pow_1_d0*(((11.0/32.0)*(deriv_fabs_0_d0*(d_Qx0_dV_si_GND)))))/value_pow_1/value_pow_1);
    d_xav_dV_di_GND = (-(model_.B)*(deriv_pow_1_d0*(((11.0/32.0)*(deriv_fabs_0_d0*(d_Qx0_dV_di_GND)))))/value_pow_1/value_pow_1);
    d_xav_dV_sf_GND = (-(model_.B)*(deriv_pow_1_d0*(((11.0/32.0)*(deriv_fabs_0_d0*(d_Qx0_dV_sf_GND)))))/value_pow_1/value_pow_1);
    xav = ((model_.B)/value_pow_1);
  }

  d_Cstern_dV_si_GND = (-((model_.eps)*8.854187817e-12)*d_xav_dV_si_GND/xav/xav);
  d_Cstern_dV_di_GND = (-((model_.eps)*8.854187817e-12)*d_xav_dV_di_GND/xav/xav);
  d_Cstern_dV_sf_GND = (-((model_.eps)*8.854187817e-12)*d_xav_dV_sf_GND/xav/xav);
  Cstern = (((model_.eps)*8.854187817e-12)/xav);

  d_Cgc_dV_si_GND = ((((model_.Cins)+Cstern)*((model_.Cins)*d_Cstern_dV_si_GND)-((model_.Cins)*Cstern)*d_Cstern_dV_si_GND)/((model_.Cins)+Cstern)/((model_.Cins)+Cstern));
  d_Cgc_dV_di_GND = ((((model_.Cins)+Cstern)*((model_.Cins)*d_Cstern_dV_di_GND)-((model_.Cins)*Cstern)*d_Cstern_dV_di_GND)/((model_.Cins)+Cstern)/((model_.Cins)+Cstern));
  d_Cgc_dV_sf_GND = ((((model_.Cins)+Cstern)*((model_.Cins)*d_Cstern_dV_sf_GND)-((model_.Cins)*Cstern)*d_Cstern_dV_sf_GND)/((model_.Cins)+Cstern)/((model_.Cins)+Cstern));
  Cgc = (((model_.Cins)*Cstern)/((model_.Cins)+Cstern));
  {
    double value_fabs_0 = fabs(((model_.nd)*Vdsi));
    double  deriv_fabs_0_d0 = (((((model_.nd)*Vdsi))>=0)?(+1.0):(-1.0));

    d_n_dV_si_GND = (deriv_fabs_0_d0*(((model_.nd)*d_Vdsi_dV_si_GND)));
    d_n_dV_di_GND = (deriv_fabs_0_d0*(((model_.nd)*d_Vdsi_dV_di_GND)));
    n = ((model_.n0)+value_fabs_0);
  }
  // V(sf,GND) <+ ((((Vgsi+(delta*Vdsi))+(Qx0/Cgc))/n))
  staticContributions[admsBRA_ID_sf_GND] += (((Vgsi+((model_.delta)*Vdsi))+(Qx0/Cgc))/n);
  d_staticContributions[admsBRA_ID_sf_GND][admsProbeID_V_sf_GND] += (((Cgc*d_Qx0_dV_sf_GND-Qx0*d_Cgc_dV_sf_GND)/Cgc/Cgc)/n);
  d_staticContributions[admsBRA_ID_sf_GND][admsProbeID_V_si_GND] += ((n*((d_Vgsi_dV_si_GND+((model_.delta)*d_Vdsi_dV_si_GND))+((Cgc*d_Qx0_dV_si_GND-Qx0*d_Cgc_dV_si_GND)/Cgc/Cgc))-((Vgsi+((model_.delta)*Vdsi))+(Qx0/Cgc))*d_n_dV_si_GND)/n/n);
  d_staticContributions[admsBRA_ID_sf_GND][admsProbeID_V_g_GND] += (d_Vgsi_dV_g_GND/n);
  d_staticContributions[admsBRA_ID_sf_GND][admsProbeID_V_di_GND] += ((n*((d_Vgsi_dV_di_GND+((model_.delta)*d_Vdsi_dV_di_GND))+((Cgc*d_Qx0_dV_di_GND-Qx0*d_Cgc_dV_di_GND)/Cgc/Cgc))-((Vgsi+((model_.delta)*Vdsi))+(Qx0/Cgc))*d_n_dV_di_GND)/n/n);

  d_f1_dV_si_GND = ((((-d_Tx_dV_si_GND)*Fs)+((Tx*d_Fd_dV_si_GND)+(d_Tx_dV_si_GND*Fd)))/(2.0*Fs));
  d_f1_dV_di_GND = ((((-d_Tx_dV_di_GND)*Fs)+((Tx*d_Fd_dV_di_GND)+(d_Tx_dV_di_GND*Fd)))/(2.0*Fs));
  d_f1_dV_sf_GND = (((2.0*Fs)*((((2.0-Tx)*d_Fs_dV_sf_GND)+((-d_Tx_dV_sf_GND)*Fs))+((Tx*d_Fd_dV_sf_GND)+(d_Tx_dV_sf_GND*Fd)))-(((2.0-Tx)*Fs)+(Tx*Fd))*(2.0*d_Fs_dV_sf_GND))/(2.0*Fs)/(2.0*Fs));
  f1 = ((((2.0-Tx)*Fs)+(Tx*Fd))/(2.0*Fs));

  d_Vdsat_dV_si_GND = ((((2.0*phit)*(lambda+Leff))/(lambda+((2.0*(model_.ksee))*Leff)))*d_f1_dV_si_GND);
  d_Vdsat_dV_di_GND = ((((2.0*phit)*(lambda+Leff))/(lambda+((2.0*(model_.ksee))*Leff)))*d_f1_dV_di_GND);
  d_Vdsat_dV_sf_GND = (((((2.0*phit)*(lambda+Leff))/(lambda+((2.0*(model_.ksee))*Leff)))*d_f1_dV_sf_GND)+((((lambda+((2.0*(model_.ksee))*Leff))*((2.0*phit)*d_lambda_dV_sf_GND)-((2.0*phit)*(lambda+Leff))*d_lambda_dV_sf_GND)/(lambda+((2.0*(model_.ksee))*Leff))/(lambda+((2.0*(model_.ksee))*Leff)))*f1));
  Vdsat = ((((2.0*phit)*(lambda+Leff))/(lambda+((2.0*(model_.ksee))*Leff)))*f1);
  {
    double value_fabs_0 = fabs((Vdsi/Vdsat));
    double value_pow_1 = pow(value_fabs_0,(model_.beta));
    double  deriv_fabs_0_d0 = ((((Vdsi/Vdsat))>=0)?(+1.0):(-1.0));
    double  deriv_pow_1_d0 = ((value_fabs_0 == 0.0)?0.0:(value_pow_1*(model_.beta)/value_fabs_0));

    d_Vdsatbeta_dV_sf_GND = (deriv_pow_1_d0*((deriv_fabs_0_d0*((-Vdsi*d_Vdsat_dV_sf_GND/Vdsat/Vdsat)))));
    d_Vdsatbeta_dV_si_GND = (deriv_pow_1_d0*((deriv_fabs_0_d0*(((Vdsat*d_Vdsi_dV_si_GND-Vdsi*d_Vdsat_dV_si_GND)/Vdsat/Vdsat)))));
    d_Vdsatbeta_dV_di_GND = (deriv_pow_1_d0*((deriv_fabs_0_d0*(((Vdsat*d_Vdsi_dV_di_GND-Vdsi*d_Vdsat_dV_di_GND)/Vdsat/Vdsat)))));
    Vdsatbeta = value_pow_1;
  }
  {
    double value_fabs_0 = fabs((Vdsi/Vdsat));
    double value_pow_1 = pow((1.0+Vdsatbeta),(1.0/(model_.beta)));
    double  deriv_fabs_0_d0 = ((((Vdsi/Vdsat))>=0)?(+1.0):(-1.0));
    double  deriv_pow_1_d0 = (((1.0+Vdsatbeta) == 0.0)?0.0:(value_pow_1*(1.0/(model_.beta))/(1.0+Vdsatbeta)));

    d_Fsat_dV_sf_GND = ((value_pow_1*(deriv_fabs_0_d0*((-Vdsi*d_Vdsat_dV_sf_GND/Vdsat/Vdsat)))-value_fabs_0*(deriv_pow_1_d0*(d_Vdsatbeta_dV_sf_GND)))/value_pow_1/value_pow_1);
    d_Fsat_dV_si_GND = ((value_pow_1*(deriv_fabs_0_d0*(((Vdsat*d_Vdsi_dV_si_GND-Vdsi*d_Vdsat_dV_si_GND)/Vdsat/Vdsat)))-value_fabs_0*(deriv_pow_1_d0*(d_Vdsatbeta_dV_si_GND)))/value_pow_1/value_pow_1);
    d_Fsat_dV_di_GND = ((value_pow_1*(deriv_fabs_0_d0*(((Vdsat*d_Vdsi_dV_di_GND-Vdsi*d_Vdsat_dV_di_GND)/Vdsat/Vdsat)))-value_fabs_0*(deriv_pow_1_d0*(d_Vdsatbeta_dV_di_GND)))/value_pow_1/value_pow_1);
    Fsat = (value_fabs_0/value_pow_1);
  }

  d_vx0_dV_sf_GND = (((lambda+((2.0*(model_.ksee))*Leff))*((vT*d_lambda_dV_sf_GND)+(d_vT_dV_sf_GND*lambda))-(vT*lambda)*d_lambda_dV_sf_GND)/(lambda+((2.0*(model_.ksee))*Leff))/(lambda+((2.0*(model_.ksee))*Leff)));
  vx0 = ((vT*lambda)/(lambda+((2.0*(model_.ksee))*Leff)));
  {
    double value_fabs_0 = fabs(Qx0);
    double  deriv_fabs_0_d0 = (((Qx0)>=0)?(+1.0):(-1.0));

    d_Id_dV_si_GND = ((((value_fabs_0*d_Fsat_dV_si_GND)+((deriv_fabs_0_d0*(d_Qx0_dV_si_GND))*Fsat))*vx0)*(model_.W));
    d_Id_dV_di_GND = ((((value_fabs_0*d_Fsat_dV_di_GND)+((deriv_fabs_0_d0*(d_Qx0_dV_di_GND))*Fsat))*vx0)*(model_.W));
    d_Id_dV_sf_GND = ((((value_fabs_0*Fsat)*d_vx0_dV_sf_GND)+(((value_fabs_0*d_Fsat_dV_sf_GND)+((deriv_fabs_0_d0*(d_Qx0_dV_sf_GND))*Fsat))*vx0))*(model_.W));
    Id = (((value_fabs_0*Fsat)*vx0)*(model_.W));
  }
  Qacc = (1.6021766208e-19*(model_.nacc));
  Id_sat = (((model_.W)*Qacc)*vT_acc);
  {
    double value_fabs_0 = fabs((Id/Id_sat));
    double value_pow_1 = pow(value_fabs_0,(model_.beta));
    double  deriv_fabs_0_d0 = ((((Id/Id_sat))>=0)?(+1.0):(-1.0));
    double  deriv_pow_1_d0 = ((value_fabs_0 == 0.0)?0.0:(value_pow_1*(model_.beta)/value_fabs_0));

    d_Idsatbeta_dV_si_GND = (deriv_pow_1_d0*((deriv_fabs_0_d0*((d_Id_dV_si_GND/Id_sat)))));
    d_Idsatbeta_dV_di_GND = (deriv_pow_1_d0*((deriv_fabs_0_d0*((d_Id_dV_di_GND/Id_sat)))));
    d_Idsatbeta_dV_sf_GND = (deriv_pow_1_d0*((deriv_fabs_0_d0*((d_Id_dV_sf_GND/Id_sat)))));
    Idsatbeta = value_pow_1;
  }
  {
    double value_pow_0 = pow((1-Idsatbeta),(1.0/(model_.beta)));
    double  deriv_pow_0_d0 = (((1-Idsatbeta) == 0.0)?0.0:(value_pow_0*(1.0/(model_.beta))/(1-Idsatbeta)));

    d_Rs_dV_si_GND = (-Rc*(deriv_pow_0_d0*((-d_Idsatbeta_dV_si_GND)))/value_pow_0/value_pow_0);
    d_Rs_dV_di_GND = (-Rc*(deriv_pow_0_d0*((-d_Idsatbeta_dV_di_GND)))/value_pow_0/value_pow_0);
    d_Rs_dV_sf_GND = (-Rc*(deriv_pow_0_d0*((-d_Idsatbeta_dV_sf_GND)))/value_pow_0/value_pow_0);
    Rs = (Rc/value_pow_0);
  }

  d_Rd_dV_si_GND = d_Rs_dV_si_GND;
  d_Rd_dV_di_GND = d_Rs_dV_di_GND;
  d_Rd_dV_sf_GND = d_Rs_dV_sf_GND;
  Rd = Rs;
  // I(di,si) <+ (((type*dir)*Id))
  staticContributions[admsNodeID_di] += (((model_.type)*dir)*Id);
  d_staticContributions[admsNodeID_di][admsProbeID_V_si_GND] += (((model_.type)*dir)*d_Id_dV_si_GND);
  d_staticContributions[admsNodeID_di][admsProbeID_V_di_GND] += (((model_.type)*dir)*d_Id_dV_di_GND);
  d_staticContributions[admsNodeID_di][admsProbeID_V_sf_GND] += (((model_.type)*dir)*d_Id_dV_sf_GND);
  staticContributions[admsNodeID_si] -= (((model_.type)*dir)*Id);
  d_staticContributions[admsNodeID_si][admsProbeID_V_si_GND] -= (((model_.type)*dir)*d_Id_dV_si_GND);
  d_staticContributions[admsNodeID_si][admsProbeID_V_di_GND] -= (((model_.type)*dir)*d_Id_dV_di_GND);
  d_staticContributions[admsNodeID_si][admsProbeID_V_sf_GND] -= (((model_.type)*dir)*d_Id_dV_sf_GND);
  // I(d,di) <+ (((V(d,GND)-V(di,GND))/Rd))
  staticContributions[admsNodeID_d] += (((probeVars[admsProbeID_V_d_GND])-(probeVars[admsProbeID_V_di_GND]))/Rd);
  d_staticContributions[admsNodeID_d][admsProbeID_V_si_GND] += (-((probeVars[admsProbeID_V_d_GND])-(probeVars[admsProbeID_V_di_GND]))*d_Rd_dV_si_GND/Rd/Rd);
  d_staticContributions[admsNodeID_d][admsProbeID_V_sf_GND] += (-((probeVars[admsProbeID_V_d_GND])-(probeVars[admsProbeID_V_di_GND]))*d_Rd_dV_sf_GND/Rd/Rd);
  d_staticContributions[admsNodeID_d][admsProbeID_V_di_GND] += ((Rd*(-d_probeVars[admsProbeID_V_di_GND][admsProbeID_V_di_GND])-((probeVars[admsProbeID_V_d_GND])-(probeVars[admsProbeID_V_di_GND]))*d_Rd_dV_di_GND)/Rd/Rd);
  d_staticContributions[admsNodeID_d][admsProbeID_V_d_GND] += (d_probeVars[admsProbeID_V_d_GND][admsProbeID_V_d_GND]/Rd);
  staticContributions[admsNodeID_di] -= (((probeVars[admsProbeID_V_d_GND])-(probeVars[admsProbeID_V_di_GND]))/Rd);
  d_staticContributions[admsNodeID_di][admsProbeID_V_si_GND] -= (-((probeVars[admsProbeID_V_d_GND])-(probeVars[admsProbeID_V_di_GND]))*d_Rd_dV_si_GND/Rd/Rd);
  d_staticContributions[admsNodeID_di][admsProbeID_V_sf_GND] -= (-((probeVars[admsProbeID_V_d_GND])-(probeVars[admsProbeID_V_di_GND]))*d_Rd_dV_sf_GND/Rd/Rd);
  d_staticContributions[admsNodeID_di][admsProbeID_V_di_GND] -= ((Rd*(-d_probeVars[admsProbeID_V_di_GND][admsProbeID_V_di_GND])-((probeVars[admsProbeID_V_d_GND])-(probeVars[admsProbeID_V_di_GND]))*d_Rd_dV_di_GND)/Rd/Rd);
  d_staticContributions[admsNodeID_di][admsProbeID_V_d_GND] -= (d_probeVars[admsProbeID_V_d_GND][admsProbeID_V_d_GND]/Rd);
  // I(si,s) <+ (((V(si,GND)-V(s,GND))/Rs))
  staticContributions[admsNodeID_si] += (((probeVars[admsProbeID_V_si_GND])-(probeVars[admsProbeID_V_s_GND]))/Rs);
  d_staticContributions[admsNodeID_si][admsProbeID_V_di_GND] += (-((probeVars[admsProbeID_V_si_GND])-(probeVars[admsProbeID_V_s_GND]))*d_Rs_dV_di_GND/Rs/Rs);
  d_staticContributions[admsNodeID_si][admsProbeID_V_sf_GND] += (-((probeVars[admsProbeID_V_si_GND])-(probeVars[admsProbeID_V_s_GND]))*d_Rs_dV_sf_GND/Rs/Rs);
  d_staticContributions[admsNodeID_si][admsProbeID_V_s_GND] += ((-d_probeVars[admsProbeID_V_s_GND][admsProbeID_V_s_GND])/Rs);
  d_staticContributions[admsNodeID_si][admsProbeID_V_si_GND] += ((Rs*d_probeVars[admsProbeID_V_si_GND][admsProbeID_V_si_GND]-((probeVars[admsProbeID_V_si_GND])-(probeVars[admsProbeID_V_s_GND]))*d_Rs_dV_si_GND)/Rs/Rs);
  staticContributions[admsNodeID_s] -= (((probeVars[admsProbeID_V_si_GND])-(probeVars[admsProbeID_V_s_GND]))/Rs);
  d_staticContributions[admsNodeID_s][admsProbeID_V_di_GND] -= (-((probeVars[admsProbeID_V_si_GND])-(probeVars[admsProbeID_V_s_GND]))*d_Rs_dV_di_GND/Rs/Rs);
  d_staticContributions[admsNodeID_s][admsProbeID_V_sf_GND] -= (-((probeVars[admsProbeID_V_si_GND])-(probeVars[admsProbeID_V_s_GND]))*d_Rs_dV_sf_GND/Rs/Rs);
  d_staticContributions[admsNodeID_s][admsProbeID_V_s_GND] -= ((-d_probeVars[admsProbeID_V_s_GND][admsProbeID_V_s_GND])/Rs);
  d_staticContributions[admsNodeID_s][admsProbeID_V_si_GND] -= ((Rs*d_probeVars[admsProbeID_V_si_GND][admsProbeID_V_si_GND]-((probeVars[admsProbeID_V_si_GND])-(probeVars[admsProbeID_V_s_GND]))*d_Rs_dV_si_GND)/Rs/Rs);

  // Additional term resulting from contributions into V(sf,GND)
  staticContributions[admsNodeID_sf] += probeVars[admsProbeID_I_sf_GND];
  d_staticContributions[admsNodeID_sf][admsProbeID_I_sf_GND] += d_probeVars[admsProbeID_I_sf_GND][admsProbeID_I_sf_GND];
  // Final term for branch equation admsBRA_ID_sf_GND 
  // Derivative of this term with respect to node is +/-1
  // Handling of that derivative is done explicitly in the loadDAEdFdX method
  staticContributions[admsBRA_ID_sf_GND] -= (*solVectorPtr)[li_sf];


  // -- endcode converted from analog/code block
  if (DEBUG_DEVICE && isActive(Diag::DEVICE_PARAMETERS) && getSolverState().debugTimeFlag)
  {
    Xyce::dout() << " probeVars[admsProbeID_V_sf_GND] =  "
                 <<probeVars[admsProbeID_V_sf_GND] << std::endl;
    Xyce::dout() << " probeVars[admsProbeID_V_s_GND] =  "
                 <<probeVars[admsProbeID_V_s_GND] << std::endl;
    Xyce::dout() << " probeVars[admsProbeID_V_d_GND] =  "
                 <<probeVars[admsProbeID_V_d_GND] << std::endl;
    Xyce::dout() << " probeVars[admsProbeID_V_di_GND] =  "
                 <<probeVars[admsProbeID_V_di_GND] << std::endl;
    Xyce::dout() << " probeVars[admsProbeID_V_si_GND] =  "
                 <<probeVars[admsProbeID_V_si_GND] << std::endl;
    Xyce::dout() << " probeVars[admsProbeID_V_g_GND] =  "
                 <<probeVars[admsProbeID_V_g_GND] << std::endl;
    Xyce::dout() << " staticContributions[admsNodeID_d] =  "
                 <<staticContributions[admsNodeID_d] << std::endl;
    Xyce::dout() << "    staticContributions[admsNodeID_d].dx(admsProbeID_V_sf_GND) =  " <<d_staticContributions[admsNodeID_d][admsProbeID_V_sf_GND] << std::endl;
    Xyce::dout() << "    staticContributions[admsNodeID_d].dx(admsProbeID_V_s_GND) =  " <<d_staticContributions[admsNodeID_d][admsProbeID_V_s_GND] << std::endl;
    Xyce::dout() << "    staticContributions[admsNodeID_d].dx(admsProbeID_V_d_GND) =  " <<d_staticContributions[admsNodeID_d][admsProbeID_V_d_GND] << std::endl;
    Xyce::dout() << "    staticContributions[admsNodeID_d].dx(admsProbeID_V_di_GND) =  " <<d_staticContributions[admsNodeID_d][admsProbeID_V_di_GND] << std::endl;
    Xyce::dout() << "    staticContributions[admsNodeID_d].dx(admsProbeID_V_si_GND) =  " <<d_staticContributions[admsNodeID_d][admsProbeID_V_si_GND] << std::endl;
    Xyce::dout() << "    staticContributions[admsNodeID_d].dx(admsProbeID_V_g_GND) =  " <<d_staticContributions[admsNodeID_d][admsProbeID_V_g_GND] << std::endl;
    Xyce::dout() << " dynamicContributions[admsNodeID_d] =  "
                 <<dynamicContributions[admsNodeID_d] << std::endl;
    Xyce::dout() << "    dynamicContributions[admsNodeID_d].dx(admsProbeID_V_sf_GND) =  " <<d_dynamicContributions[admsNodeID_d][admsProbeID_V_sf_GND] << std::endl;
    Xyce::dout() << "    dynamicContributions[admsNodeID_d].dx(admsProbeID_V_s_GND) =  " <<d_dynamicContributions[admsNodeID_d][admsProbeID_V_s_GND] << std::endl;
    Xyce::dout() << "    dynamicContributions[admsNodeID_d].dx(admsProbeID_V_d_GND) =  " <<d_dynamicContributions[admsNodeID_d][admsProbeID_V_d_GND] << std::endl;
    Xyce::dout() << "    dynamicContributions[admsNodeID_d].dx(admsProbeID_V_di_GND) =  " <<d_dynamicContributions[admsNodeID_d][admsProbeID_V_di_GND] << std::endl;
    Xyce::dout() << "    dynamicContributions[admsNodeID_d].dx(admsProbeID_V_si_GND) =  " <<d_dynamicContributions[admsNodeID_d][admsProbeID_V_si_GND] << std::endl;
    Xyce::dout() << "    dynamicContributions[admsNodeID_d].dx(admsProbeID_V_g_GND) =  " <<d_dynamicContributions[admsNodeID_d][admsProbeID_V_g_GND] << std::endl;
    Xyce::dout() << " staticContributions[admsNodeID_g] =  "
                 <<staticContributions[admsNodeID_g] << std::endl;
    Xyce::dout() << "    staticContributions[admsNodeID_g].dx(admsProbeID_V_sf_GND) =  " <<d_staticContributions[admsNodeID_g][admsProbeID_V_sf_GND] << std::endl;
    Xyce::dout() << "    staticContributions[admsNodeID_g].dx(admsProbeID_V_s_GND) =  " <<d_staticContributions[admsNodeID_g][admsProbeID_V_s_GND] << std::endl;
    Xyce::dout() << "    staticContributions[admsNodeID_g].dx(admsProbeID_V_d_GND) =  " <<d_staticContributions[admsNodeID_g][admsProbeID_V_d_GND] << std::endl;
    Xyce::dout() << "    staticContributions[admsNodeID_g].dx(admsProbeID_V_di_GND) =  " <<d_staticContributions[admsNodeID_g][admsProbeID_V_di_GND] << std::endl;
    Xyce::dout() << "    staticContributions[admsNodeID_g].dx(admsProbeID_V_si_GND) =  " <<d_staticContributions[admsNodeID_g][admsProbeID_V_si_GND] << std::endl;
    Xyce::dout() << "    staticContributions[admsNodeID_g].dx(admsProbeID_V_g_GND) =  " <<d_staticContributions[admsNodeID_g][admsProbeID_V_g_GND] << std::endl;
    Xyce::dout() << " dynamicContributions[admsNodeID_g] =  "
                 <<dynamicContributions[admsNodeID_g] << std::endl;
    Xyce::dout() << "    dynamicContributions[admsNodeID_g].dx(admsProbeID_V_sf_GND) =  " <<d_dynamicContributions[admsNodeID_g][admsProbeID_V_sf_GND] << std::endl;
    Xyce::dout() << "    dynamicContributions[admsNodeID_g].dx(admsProbeID_V_s_GND) =  " <<d_dynamicContributions[admsNodeID_g][admsProbeID_V_s_GND] << std::endl;
    Xyce::dout() << "    dynamicContributions[admsNodeID_g].dx(admsProbeID_V_d_GND) =  " <<d_dynamicContributions[admsNodeID_g][admsProbeID_V_d_GND] << std::endl;
    Xyce::dout() << "    dynamicContributions[admsNodeID_g].dx(admsProbeID_V_di_GND) =  " <<d_dynamicContributions[admsNodeID_g][admsProbeID_V_di_GND] << std::endl;
    Xyce::dout() << "    dynamicContributions[admsNodeID_g].dx(admsProbeID_V_si_GND) =  " <<d_dynamicContributions[admsNodeID_g][admsProbeID_V_si_GND] << std::endl;
    Xyce::dout() << "    dynamicContributions[admsNodeID_g].dx(admsProbeID_V_g_GND) =  " <<d_dynamicContributions[admsNodeID_g][admsProbeID_V_g_GND] << std::endl;
    Xyce::dout() << " staticContributions[admsNodeID_s] =  "
                 <<staticContributions[admsNodeID_s] << std::endl;
    Xyce::dout() << "    staticContributions[admsNodeID_s].dx(admsProbeID_V_sf_GND) =  " <<d_staticContributions[admsNodeID_s][admsProbeID_V_sf_GND] << std::endl;
    Xyce::dout() << "    staticContributions[admsNodeID_s].dx(admsProbeID_V_s_GND) =  " <<d_staticContributions[admsNodeID_s][admsProbeID_V_s_GND] << std::endl;
    Xyce::dout() << "    staticContributions[admsNodeID_s].dx(admsProbeID_V_d_GND) =  " <<d_staticContributions[admsNodeID_s][admsProbeID_V_d_GND] << std::endl;
    Xyce::dout() << "    staticContributions[admsNodeID_s].dx(admsProbeID_V_di_GND) =  " <<d_staticContributions[admsNodeID_s][admsProbeID_V_di_GND] << std::endl;
    Xyce::dout() << "    staticContributions[admsNodeID_s].dx(admsProbeID_V_si_GND) =  " <<d_staticContributions[admsNodeID_s][admsProbeID_V_si_GND] << std::endl;
    Xyce::dout() << "    staticContributions[admsNodeID_s].dx(admsProbeID_V_g_GND) =  " <<d_staticContributions[admsNodeID_s][admsProbeID_V_g_GND] << std::endl;
    Xyce::dout() << " dynamicContributions[admsNodeID_s] =  "
                 <<dynamicContributions[admsNodeID_s] << std::endl;
    Xyce::dout() << "    dynamicContributions[admsNodeID_s].dx(admsProbeID_V_sf_GND) =  " <<d_dynamicContributions[admsNodeID_s][admsProbeID_V_sf_GND] << std::endl;
    Xyce::dout() << "    dynamicContributions[admsNodeID_s].dx(admsProbeID_V_s_GND) =  " <<d_dynamicContributions[admsNodeID_s][admsProbeID_V_s_GND] << std::endl;
    Xyce::dout() << "    dynamicContributions[admsNodeID_s].dx(admsProbeID_V_d_GND) =  " <<d_dynamicContributions[admsNodeID_s][admsProbeID_V_d_GND] << std::endl;
    Xyce::dout() << "    dynamicContributions[admsNodeID_s].dx(admsProbeID_V_di_GND) =  " <<d_dynamicContributions[admsNodeID_s][admsProbeID_V_di_GND] << std::endl;
    Xyce::dout() << "    dynamicContributions[admsNodeID_s].dx(admsProbeID_V_si_GND) =  " <<d_dynamicContributions[admsNodeID_s][admsProbeID_V_si_GND] << std::endl;
    Xyce::dout() << "    dynamicContributions[admsNodeID_s].dx(admsProbeID_V_g_GND) =  " <<d_dynamicContributions[admsNodeID_s][admsProbeID_V_g_GND] << std::endl;
    Xyce::dout() << " staticContributions[admsNodeID_di] =  "
                 <<staticContributions[admsNodeID_di] << std::endl;
    Xyce::dout() << "    staticContributions[admsNodeID_di].dx(admsProbeID_V_sf_GND) =  " <<d_staticContributions[admsNodeID_di][admsProbeID_V_sf_GND] << std::endl;
    Xyce::dout() << "    staticContributions[admsNodeID_di].dx(admsProbeID_V_s_GND) =  " <<d_staticContributions[admsNodeID_di][admsProbeID_V_s_GND] << std::endl;
    Xyce::dout() << "    staticContributions[admsNodeID_di].dx(admsProbeID_V_d_GND) =  " <<d_staticContributions[admsNodeID_di][admsProbeID_V_d_GND] << std::endl;
    Xyce::dout() << "    staticContributions[admsNodeID_di].dx(admsProbeID_V_di_GND) =  " <<d_staticContributions[admsNodeID_di][admsProbeID_V_di_GND] << std::endl;
    Xyce::dout() << "    staticContributions[admsNodeID_di].dx(admsProbeID_V_si_GND) =  " <<d_staticContributions[admsNodeID_di][admsProbeID_V_si_GND] << std::endl;
    Xyce::dout() << "    staticContributions[admsNodeID_di].dx(admsProbeID_V_g_GND) =  " <<d_staticContributions[admsNodeID_di][admsProbeID_V_g_GND] << std::endl;
    Xyce::dout() << " dynamicContributions[admsNodeID_di] =  "
                 <<dynamicContributions[admsNodeID_di] << std::endl;
    Xyce::dout() << "    dynamicContributions[admsNodeID_di].dx(admsProbeID_V_sf_GND) =  " <<d_dynamicContributions[admsNodeID_di][admsProbeID_V_sf_GND] << std::endl;
    Xyce::dout() << "    dynamicContributions[admsNodeID_di].dx(admsProbeID_V_s_GND) =  " <<d_dynamicContributions[admsNodeID_di][admsProbeID_V_s_GND] << std::endl;
    Xyce::dout() << "    dynamicContributions[admsNodeID_di].dx(admsProbeID_V_d_GND) =  " <<d_dynamicContributions[admsNodeID_di][admsProbeID_V_d_GND] << std::endl;
    Xyce::dout() << "    dynamicContributions[admsNodeID_di].dx(admsProbeID_V_di_GND) =  " <<d_dynamicContributions[admsNodeID_di][admsProbeID_V_di_GND] << std::endl;
    Xyce::dout() << "    dynamicContributions[admsNodeID_di].dx(admsProbeID_V_si_GND) =  " <<d_dynamicContributions[admsNodeID_di][admsProbeID_V_si_GND] << std::endl;
    Xyce::dout() << "    dynamicContributions[admsNodeID_di].dx(admsProbeID_V_g_GND) =  " <<d_dynamicContributions[admsNodeID_di][admsProbeID_V_g_GND] << std::endl;
    Xyce::dout() << " staticContributions[admsNodeID_si] =  "
                 <<staticContributions[admsNodeID_si] << std::endl;
    Xyce::dout() << "    staticContributions[admsNodeID_si].dx(admsProbeID_V_sf_GND) =  " <<d_staticContributions[admsNodeID_si][admsProbeID_V_sf_GND] << std::endl;
    Xyce::dout() << "    staticContributions[admsNodeID_si].dx(admsProbeID_V_s_GND) =  " <<d_staticContributions[admsNodeID_si][admsProbeID_V_s_GND] << std::endl;
    Xyce::dout() << "    staticContributions[admsNodeID_si].dx(admsProbeID_V_d_GND) =  " <<d_staticContributions[admsNodeID_si][admsProbeID_V_d_GND] << std::endl;
    Xyce::dout() << "    staticContributions[admsNodeID_si].dx(admsProbeID_V_di_GND) =  " <<d_staticContributions[admsNodeID_si][admsProbeID_V_di_GND] << std::endl;
    Xyce::dout() << "    staticContributions[admsNodeID_si].dx(admsProbeID_V_si_GND) =  " <<d_staticContributions[admsNodeID_si][admsProbeID_V_si_GND] << std::endl;
    Xyce::dout() << "    staticContributions[admsNodeID_si].dx(admsProbeID_V_g_GND) =  " <<d_staticContributions[admsNodeID_si][admsProbeID_V_g_GND] << std::endl;
    Xyce::dout() << " dynamicContributions[admsNodeID_si] =  "
                 <<dynamicContributions[admsNodeID_si] << std::endl;
    Xyce::dout() << "    dynamicContributions[admsNodeID_si].dx(admsProbeID_V_sf_GND) =  " <<d_dynamicContributions[admsNodeID_si][admsProbeID_V_sf_GND] << std::endl;
    Xyce::dout() << "    dynamicContributions[admsNodeID_si].dx(admsProbeID_V_s_GND) =  " <<d_dynamicContributions[admsNodeID_si][admsProbeID_V_s_GND] << std::endl;
    Xyce::dout() << "    dynamicContributions[admsNodeID_si].dx(admsProbeID_V_d_GND) =  " <<d_dynamicContributions[admsNodeID_si][admsProbeID_V_d_GND] << std::endl;
    Xyce::dout() << "    dynamicContributions[admsNodeID_si].dx(admsProbeID_V_di_GND) =  " <<d_dynamicContributions[admsNodeID_si][admsProbeID_V_di_GND] << std::endl;
    Xyce::dout() << "    dynamicContributions[admsNodeID_si].dx(admsProbeID_V_si_GND) =  " <<d_dynamicContributions[admsNodeID_si][admsProbeID_V_si_GND] << std::endl;
    Xyce::dout() << "    dynamicContributions[admsNodeID_si].dx(admsProbeID_V_g_GND) =  " <<d_dynamicContributions[admsNodeID_si][admsProbeID_V_g_GND] << std::endl;
    Xyce::dout() << " staticContributions[admsNodeID_sf] =  "
                 <<staticContributions[admsNodeID_sf] << std::endl;
    Xyce::dout() << "    staticContributions[admsNodeID_sf].dx(admsProbeID_V_sf_GND) =  " <<d_staticContributions[admsNodeID_sf][admsProbeID_V_sf_GND] << std::endl;
    Xyce::dout() << "    staticContributions[admsNodeID_sf].dx(admsProbeID_V_s_GND) =  " <<d_staticContributions[admsNodeID_sf][admsProbeID_V_s_GND] << std::endl;
    Xyce::dout() << "    staticContributions[admsNodeID_sf].dx(admsProbeID_V_d_GND) =  " <<d_staticContributions[admsNodeID_sf][admsProbeID_V_d_GND] << std::endl;
    Xyce::dout() << "    staticContributions[admsNodeID_sf].dx(admsProbeID_V_di_GND) =  " <<d_staticContributions[admsNodeID_sf][admsProbeID_V_di_GND] << std::endl;
    Xyce::dout() << "    staticContributions[admsNodeID_sf].dx(admsProbeID_V_si_GND) =  " <<d_staticContributions[admsNodeID_sf][admsProbeID_V_si_GND] << std::endl;
    Xyce::dout() << "    staticContributions[admsNodeID_sf].dx(admsProbeID_V_g_GND) =  " <<d_staticContributions[admsNodeID_sf][admsProbeID_V_g_GND] << std::endl;
    Xyce::dout() << " dynamicContributions[admsNodeID_sf] =  "
                 <<dynamicContributions[admsNodeID_sf] << std::endl;
    Xyce::dout() << "    dynamicContributions[admsNodeID_sf].dx(admsProbeID_V_sf_GND) =  " <<d_dynamicContributions[admsNodeID_sf][admsProbeID_V_sf_GND] << std::endl;
    Xyce::dout() << "    dynamicContributions[admsNodeID_sf].dx(admsProbeID_V_s_GND) =  " <<d_dynamicContributions[admsNodeID_sf][admsProbeID_V_s_GND] << std::endl;
    Xyce::dout() << "    dynamicContributions[admsNodeID_sf].dx(admsProbeID_V_d_GND) =  " <<d_dynamicContributions[admsNodeID_sf][admsProbeID_V_d_GND] << std::endl;
    Xyce::dout() << "    dynamicContributions[admsNodeID_sf].dx(admsProbeID_V_di_GND) =  " <<d_dynamicContributions[admsNodeID_sf][admsProbeID_V_di_GND] << std::endl;
    Xyce::dout() << "    dynamicContributions[admsNodeID_sf].dx(admsProbeID_V_si_GND) =  " <<d_dynamicContributions[admsNodeID_sf][admsProbeID_V_si_GND] << std::endl;
    Xyce::dout() << "    dynamicContributions[admsNodeID_sf].dx(admsProbeID_V_g_GND) =  " <<d_dynamicContributions[admsNodeID_sf][admsProbeID_V_g_GND] << std::endl;
    Xyce::dout() << " staticContributions[admsBRA_ID_sf_GND] =  "
                 <<staticContributions[admsBRA_ID_sf_GND] << std::endl;
    Xyce::dout() << "    staticContributions[admsBRA_ID_sf_GND].dx(admsProbeID_V_sf_GND) =  " <<d_staticContributions[admsBRA_ID_sf_GND][admsProbeID_V_sf_GND] << std::endl;
    Xyce::dout() << "    staticContributions[admsBRA_ID_sf_GND].dx(admsProbeID_V_s_GND) =  " <<d_staticContributions[admsBRA_ID_sf_GND][admsProbeID_V_s_GND] << std::endl;
    Xyce::dout() << "    staticContributions[admsBRA_ID_sf_GND].dx(admsProbeID_V_d_GND) =  " <<d_staticContributions[admsBRA_ID_sf_GND][admsProbeID_V_d_GND] << std::endl;
    Xyce::dout() << "    staticContributions[admsBRA_ID_sf_GND].dx(admsProbeID_V_di_GND) =  " <<d_staticContributions[admsBRA_ID_sf_GND][admsProbeID_V_di_GND] << std::endl;
    Xyce::dout() << "    staticContributions[admsBRA_ID_sf_GND].dx(admsProbeID_V_si_GND) =  " <<d_staticContributions[admsBRA_ID_sf_GND][admsProbeID_V_si_GND] << std::endl;
    Xyce::dout() << "    staticContributions[admsBRA_ID_sf_GND].dx(admsProbeID_V_g_GND) =  " <<d_staticContributions[admsBRA_ID_sf_GND][admsProbeID_V_g_GND] << std::endl;
    Xyce::dout() << " dynamicContributions[admsBRA_ID_sf_GND] =  "
                 <<dynamicContributions[admsBRA_ID_sf_GND] << std::endl;
    Xyce::dout() << "    dynamicContributions[admsBRA_ID_sf_GND].dx(admsProbeID_V_sf_GND) =  " <<d_dynamicContributions[admsBRA_ID_sf_GND][admsProbeID_V_sf_GND] << std::endl;
    Xyce::dout() << "    dynamicContributions[admsBRA_ID_sf_GND].dx(admsProbeID_V_s_GND) =  " <<d_dynamicContributions[admsBRA_ID_sf_GND][admsProbeID_V_s_GND] << std::endl;
    Xyce::dout() << "    dynamicContributions[admsBRA_ID_sf_GND].dx(admsProbeID_V_d_GND) =  " <<d_dynamicContributions[admsBRA_ID_sf_GND][admsProbeID_V_d_GND] << std::endl;
    Xyce::dout() << "    dynamicContributions[admsBRA_ID_sf_GND].dx(admsProbeID_V_di_GND) =  " <<d_dynamicContributions[admsBRA_ID_sf_GND][admsProbeID_V_di_GND] << std::endl;
    Xyce::dout() << "    dynamicContributions[admsBRA_ID_sf_GND].dx(admsProbeID_V_si_GND) =  " <<d_dynamicContributions[admsBRA_ID_sf_GND][admsProbeID_V_si_GND] << std::endl;
    Xyce::dout() << "    dynamicContributions[admsBRA_ID_sf_GND].dx(admsProbeID_V_g_GND) =  " <<d_dynamicContributions[admsBRA_ID_sf_GND][admsProbeID_V_g_GND] << std::endl;

    if (!origFlag)
      Xyce::dout() << "This step was limited by this device." << std::endl;
  }


  if (loadLeadCurrent)
  {
    // If needed, we must now copy all the data from staticContributions
    // and dynamicContributionsinto the lead current F vector
    // Must make sure all collapsed node contributions get summed into the
    // external nodes properly.
    for ( int unmappedNode=0; unmappedNode < 3 ; unmappedNode++)
    {
      leadCurrentF[unmappedNode] = 0.0;
      leadCurrentQ[unmappedNode] = 0.0;
    }
    for ( int unmappedNode=0; unmappedNode < 6; unmappedNode++)
    {
      if (nodeMap[unmappedNode] < 3 && nodeMap[unmappedNode] != -1 )
      {
        leadCurrentF[nodeMap[unmappedNode]] += staticContributions[unmappedNode];
        leadCurrentQ[nodeMap[unmappedNode]] += dynamicContributions[unmappedNode];
      }
    }
  }
  return true;
}


//-----------------------------------------------------------------------------
// Function      : Instance::loadDAEdFdx
// Purpose       :
// Special Notes : Load the dFdx ("static jacobian") matrix
// Scope         : public
// Creator       : admsXml
// Creation Date :
//-----------------------------------------------------------------------------
bool Instance::loadDAEdFdx()
{
  bool bsuccess = true;
  Linear::Matrix & dFdx = *(extData.dFdxMatrixPtr);

#ifndef Xyce_NONPOINTER_MATRIX_LOAD
  (*f_di_Equ_si_Node_Ptr) +=  +d_staticContributions[admsNodeID_di][admsProbeID_V_si_GND];
  (*f_si_Equ_si_Node_Ptr) +=  +d_staticContributions[admsNodeID_si][admsProbeID_V_si_GND];
  (*f_di_Equ_di_Node_Ptr) +=  +d_staticContributions[admsNodeID_di][admsProbeID_V_di_GND];
  (*f_si_Equ_di_Node_Ptr) +=  +d_staticContributions[admsNodeID_si][admsProbeID_V_di_GND];
  (*f_di_Equ_sf_Node_Ptr) +=  +d_staticContributions[admsNodeID_di][admsProbeID_V_sf_GND];
  (*f_si_Equ_sf_Node_Ptr) +=  +d_staticContributions[admsNodeID_si][admsProbeID_V_sf_GND];
  (*f_d_Equ_si_Node_Ptr) +=  +d_staticContributions[admsNodeID_d][admsProbeID_V_si_GND];
  (*f_d_Equ_sf_Node_Ptr) +=  +d_staticContributions[admsNodeID_d][admsProbeID_V_sf_GND];
  (*f_d_Equ_di_Node_Ptr) +=  +d_staticContributions[admsNodeID_d][admsProbeID_V_di_GND];
  (*f_d_Equ_d_Node_Ptr) +=  +d_staticContributions[admsNodeID_d][admsProbeID_V_d_GND];
  (*f_di_Equ_d_Node_Ptr) +=  +d_staticContributions[admsNodeID_di][admsProbeID_V_d_GND];
  (*f_s_Equ_di_Node_Ptr) +=  +d_staticContributions[admsNodeID_s][admsProbeID_V_di_GND];
  (*f_s_Equ_sf_Node_Ptr) +=  +d_staticContributions[admsNodeID_s][admsProbeID_V_sf_GND];
  (*f_si_Equ_s_Node_Ptr) +=  +d_staticContributions[admsNodeID_si][admsProbeID_V_s_GND];
  (*f_s_Equ_s_Node_Ptr) +=  +d_staticContributions[admsNodeID_s][admsProbeID_V_s_GND];
  (*f_s_Equ_si_Node_Ptr) +=  +d_staticContributions[admsNodeID_s][admsProbeID_V_si_GND];
  (*f_sf_Equ_BRA_sf_GND_Var_Ptr) += d_staticContributions[admsNodeID_sf][admsProbeID_I_sf_GND];
  // there also need to be extra loads for branch sf,GND
  // Load for branch sf,GND equ var sf
  // depends on probe V(sf,GND)
  (*f_BRA_sf_GND_Equ_sf_Node_Ptr) +=  +d_staticContributions[admsBRA_ID_sf_GND][admsProbeID_V_sf_GND] -1;
  // Load for branch sf,GND equ var si
  // depends on probe V(si,GND)
  (*f_BRA_sf_GND_Equ_si_Node_Ptr) +=  +d_staticContributions[admsBRA_ID_sf_GND][admsProbeID_V_si_GND];
  // Load for branch sf,GND equ var g
  // depends on probe V(g,GND)
  (*f_BRA_sf_GND_Equ_g_Node_Ptr) +=  +d_staticContributions[admsBRA_ID_sf_GND][admsProbeID_V_g_GND];
  // Load for branch sf,GND equ var di
  // depends on probe V(di,GND)
  (*f_BRA_sf_GND_Equ_di_Node_Ptr) +=  +d_staticContributions[admsBRA_ID_sf_GND][admsProbeID_V_di_GND];

#else
  //use the offsets instead of pointers
  dFdx[li_di][A_di_Equ_si_NodeOffset] +=  +d_staticContributions[admsNodeID_di][admsProbeID_V_si_GND];
  dFdx[li_si][A_si_Equ_si_NodeOffset] +=  +d_staticContributions[admsNodeID_si][admsProbeID_V_si_GND];
  dFdx[li_di][A_di_Equ_di_NodeOffset] +=  +d_staticContributions[admsNodeID_di][admsProbeID_V_di_GND];
  dFdx[li_si][A_si_Equ_di_NodeOffset] +=  +d_staticContributions[admsNodeID_si][admsProbeID_V_di_GND];
  dFdx[li_di][A_di_Equ_sf_NodeOffset] +=  +d_staticContributions[admsNodeID_di][admsProbeID_V_sf_GND];
  dFdx[li_si][A_si_Equ_sf_NodeOffset] +=  +d_staticContributions[admsNodeID_si][admsProbeID_V_sf_GND];
  dFdx[li_d][A_d_Equ_si_NodeOffset] +=  +d_staticContributions[admsNodeID_d][admsProbeID_V_si_GND];
  dFdx[li_d][A_d_Equ_sf_NodeOffset] +=  +d_staticContributions[admsNodeID_d][admsProbeID_V_sf_GND];
  dFdx[li_d][A_d_Equ_di_NodeOffset] +=  +d_staticContributions[admsNodeID_d][admsProbeID_V_di_GND];
  dFdx[li_d][A_d_Equ_d_NodeOffset] +=  +d_staticContributions[admsNodeID_d][admsProbeID_V_d_GND];
  dFdx[li_di][A_di_Equ_d_NodeOffset] +=  +d_staticContributions[admsNodeID_di][admsProbeID_V_d_GND];
  dFdx[li_s][A_s_Equ_di_NodeOffset] +=  +d_staticContributions[admsNodeID_s][admsProbeID_V_di_GND];
  dFdx[li_s][A_s_Equ_sf_NodeOffset] +=  +d_staticContributions[admsNodeID_s][admsProbeID_V_sf_GND];
  dFdx[li_si][A_si_Equ_s_NodeOffset] +=  +d_staticContributions[admsNodeID_si][admsProbeID_V_s_GND];
  dFdx[li_s][A_s_Equ_s_NodeOffset] +=  +d_staticContributions[admsNodeID_s][admsProbeID_V_s_GND];
  dFdx[li_s][A_s_Equ_si_NodeOffset] +=  +d_staticContributions[admsNodeID_s][admsProbeID_V_si_GND];
  dFdx[li_sf][A_sf_Equ_BRA_sf_GND_Var_Offset] += d_staticContributions[admsNodeID_sf][admsProbeID_I_sf_GND];
  // there also need to be extra loads for branch sf,GND
  // Load for branch sf,GND equ var sf
  // depends on probe V(sf,GND)
  dFdx[li_BRA_sf_GND][A_BRA_sf_GND_Equ_sf_Node_Offset] +=  +d_staticContributions[admsBRA_ID_sf_GND][admsProbeID_V_sf_GND] -1;
  // Load for branch sf,GND equ var si
  // depends on probe V(si,GND)
  dFdx[li_BRA_sf_GND][A_BRA_sf_GND_Equ_si_Node_Offset] +=  +d_staticContributions[admsBRA_ID_sf_GND][admsProbeID_V_si_GND];
  // Load for branch sf,GND equ var g
  // depends on probe V(g,GND)
  dFdx[li_BRA_sf_GND][A_BRA_sf_GND_Equ_g_Node_Offset] +=  +d_staticContributions[admsBRA_ID_sf_GND][admsProbeID_V_g_GND];
  // Load for branch sf,GND equ var di
  // depends on probe V(di,GND)
  dFdx[li_BRA_sf_GND][A_BRA_sf_GND_Equ_di_Node_Offset] +=  +d_staticContributions[admsBRA_ID_sf_GND][admsProbeID_V_di_GND];

#endif

  return bsuccess;
}


//-----------------------------------------------------------------------------
// Function      : Instance::loadDAEdQdx
// Purpose       :
// Special Notes : Load the dQdx ("dynamic jacobian") matrix
// Scope         : public
// Creator       : admsXml
// Creation Date :
//-----------------------------------------------------------------------------
bool Instance::loadDAEdQdx()
{
  bool bsuccess = true;
  Linear::Matrix & dQdx = *(extData.dQdxMatrixPtr);

#ifndef Xyce_NONPOINTER_MATRIX_LOAD
  (*q_sf_Equ_BRA_sf_GND_Var_Ptr) += d_dynamicContributions[admsNodeID_sf][admsProbeID_I_sf_GND];
  // there also need to be extra loads for branch sf,GND
  // Load for branch sf,GND equ var sf
  // Load for branch sf,GND equ var si
  // Load for branch sf,GND equ var g
  // Load for branch sf,GND equ var di

#else
  //use the offsets instead of pointers
  dQdx[li_sf][A_sf_Equ_BRA_sf_GND_Var_Offset] += d_dynamicContributions[admsNodeID_sf][admsProbeID_I_sf_GND];
  // there also need to be extra loads for branch sf,GND
  // Load for branch sf,GND equ var sf
  // Load for branch sf,GND equ var si
  // Load for branch sf,GND equ var g
  // Load for branch sf,GND equ var di


#endif
  return bsuccess;
}

//-----------------------------------------------------------------------------
// Function      : Instance::updateTemperature
// Purpose       : Set temperature and update any parameters that depend on it
// Special Notes : In Xyce ADMS, we'll simply copy the temperature, which is
//                 in Kelvin, to our "admsTemperature" variable, which needs
//                 to be in Celsius.
// Scope         : public
// Creator       : admsXml
// Creation Date :
//-----------------------------------------------------------------------------
bool Instance::updateTemperature(const double & temperatureTemp)
{

  admsTemperature = temperatureTemp;
  adms_vt_nom = adms_vt(temperatureTemp);

  return true;
}

// Class Model
//-----------------------------------------------------------------------------
// Function      : Model::processParams
// Purpose       :
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
//-----------------------------------------------------------------------------
bool Model::processParams()
{

  // Set any non-constant parameter defaults:
  // Set any parameters that were not given and whose defaults depend on other
  // parameters:

  // set internal model type based on model card type
  if (getType() == "pmos" || getType() == "PMOS")
    type = -1;



  // Now we need to check that any parameters are within their ranges as
  // specified in the verilog:

  //    Parameter type : [ (-1), 1 ]] 0, 0 [
  if ( (!((type >=(-1) && type <=1 )) || (type >0 && type <0 )) )
  {
    UserWarning(*this) << "ADMSmvs_2_0_0_hemt: Parameter type value " << type << " out of range [ (-1), 1 ] or  ] 0, 0 [";
  }

  //    Parameter W : ] 0,  (+inf) [
  if ( (!((W >0))) )
  {
    UserWarning(*this) << "ADMSmvs_2_0_0_hemt: Parameter W value " << W << " out of range ] 0,  (+inf) [";
  }

  //    Parameter Lgdr : ] 0,  (+inf) [
  if ( (!((Lgdr >0))) )
  {
    UserWarning(*this) << "ADMSmvs_2_0_0_hemt: Parameter Lgdr value " << Lgdr << " out of range ] 0,  (+inf) [";
  }

  //    Parameter dLg : [ 0,  (+inf) [
  if ( (!((dLg >=0))) )
  {
    UserWarning(*this) << "ADMSmvs_2_0_0_hemt: Parameter dLg value " << dLg << " out of range [ 0,  (+inf) [";
  }

  //    Parameter Cins : ] 0,  (+inf) [
  if ( (!((Cins >0))) )
  {
    UserWarning(*this) << "ADMSmvs_2_0_0_hemt: Parameter Cins value " << Cins << " out of range ] 0,  (+inf) [";
  }

  //    Parameter Tjun : ] 0,  (+inf) [
  if ( (!((Tjun >0))) )
  {
    UserWarning(*this) << "ADMSmvs_2_0_0_hemt: Parameter Tjun value " << Tjun << " out of range ] 0,  (+inf) [";
  }

  //    Parameter energy_diff_volt :  ] (-inf)  (+inf) [

  //    Parameter delta : [ 0,  (+inf) [
  if ( (!((delta >=0))) )
  {
    UserWarning(*this) << "ADMSmvs_2_0_0_hemt: Parameter delta value " << delta << " out of range [ 0,  (+inf) [";
  }

  //    Parameter n0 : [ 1.0,  (+inf) [
  if ( (!((n0 >=1.0))) )
  {
    UserWarning(*this) << "ADMSmvs_2_0_0_hemt: Parameter n0 value " << n0 << " out of range [ 1.0,  (+inf) [";
  }

  //    Parameter Rc0 : ] 0,  (+inf) [
  if ( (!((Rc0 >0))) )
  {
    UserWarning(*this) << "ADMSmvs_2_0_0_hemt: Parameter Rc0 value " << Rc0 << " out of range ] 0,  (+inf) [";
  }

  //    Parameter nacc : ] 0,  (+inf) [
  if ( (!((nacc >0))) )
  {
    UserWarning(*this) << "ADMSmvs_2_0_0_hemt: Parameter nacc value " << nacc << " out of range ] 0,  (+inf) [";
  }

  //    Parameter meff : ] 0, 1 ]
  if ( (!((meff >0 && meff <=1 ))) )
  {
    UserWarning(*this) << "ADMSmvs_2_0_0_hemt: Parameter meff value " << meff << " out of range ] 0, 1 ]";
  }

  //    Parameter np_mass : [ 0,  (+inf) [
  if ( (!((np_mass >=0))) )
  {
    UserWarning(*this) << "ADMSmvs_2_0_0_hemt: Parameter np_mass value " << np_mass << " out of range [ 0,  (+inf) [";
  }

  //    Parameter mu_eff : ] 0,  (+inf) [
  if ( (!((mu_eff >0))) )
  {
    UserWarning(*this) << "ADMSmvs_2_0_0_hemt: Parameter mu_eff value " << mu_eff << " out of range ] 0,  (+inf) [";
  }

  //    Parameter ksee : ] 0,  (+inf) [
  if ( (!((ksee >0))) )
  {
    UserWarning(*this) << "ADMSmvs_2_0_0_hemt: Parameter ksee value " << ksee << " out of range ] 0,  (+inf) [";
  }

  //    Parameter B : ] 0,  (+inf) [
  if ( (!((B >0))) )
  {
    UserWarning(*this) << "ADMSmvs_2_0_0_hemt: Parameter B value " << B << " out of range ] 0,  (+inf) [";
  }

  //    Parameter dqm0 : ] 0,  (+inf) [
  if ( (!((dqm0 >0))) )
  {
    UserWarning(*this) << "ADMSmvs_2_0_0_hemt: Parameter dqm0 value " << dqm0 << " out of range ] 0,  (+inf) [";
  }

  //    Parameter eps : ] 0,  (+inf) [
  if ( (!((eps >0))) )
  {
    UserWarning(*this) << "ADMSmvs_2_0_0_hemt: Parameter eps value " << eps << " out of range ] 0,  (+inf) [";
  }

  //    Parameter theta : ] 0,  (+inf) [
  if ( (!((theta >0))) )
  {
    UserWarning(*this) << "ADMSmvs_2_0_0_hemt: Parameter theta value " << theta << " out of range ] 0,  (+inf) [";
  }

  //    Parameter beta : [ 1,  (+inf) [
  if ( (!((beta >=1))) )
  {
    UserWarning(*this) << "ADMSmvs_2_0_0_hemt: Parameter beta value " << beta << " out of range [ 1,  (+inf) [";
  }

  //    Parameter nd : [ 0,  (+inf) [
  if ( (!((nd >=0))) )
  {
    UserWarning(*this) << "ADMSmvs_2_0_0_hemt: Parameter nd value " << nd << " out of range [ 0,  (+inf) [";
  }

  // and of course, this routine is where we should put the initial_model
  // stuff


  return true;
}
//----------------------------------------------------------------------------
// Function      : Model::processInstanceParams
// Purpose       :
// Special Notes :
// Scope         : public
// Creator       :
// Creation Date :
//----------------------------------------------------------------------------
bool Model::processInstanceParams()
{

  std::vector<Instance*>::iterator iter;
  std::vector<Instance*>::iterator first = instanceContainer.begin();
  std::vector<Instance*>::iterator last  = instanceContainer.end();

  for (iter=first; iter!=last; ++iter)
  {
    (*iter)->processParams();
  }

  return true;
}

//-----------------------------------------------------------------------------
// Function      : Model::Model
// Purpose       : model block constructor
// Special Notes :
// Scope         : public
// Creator       :
// Creation Date :
//-----------------------------------------------------------------------------
Model::Model(
   const Configuration & configuration,
   const ModelBlock &    model_block,
   const FactoryBlock &  factory_block)
  : DeviceModel(model_block, configuration.getModelParameters(), factory_block),
    version(2.00),
    type(1),
    W(1.0e-6),
    Lgdr(80.0e-9),
    dLg(10.5e-9),
    Cins(3.17e-2),
    Tjun(300.0),
    energy_diff_volt(0.153),
    delta(0.120),
    n0(1.35),
    Rc0(160.0e-6),
    nacc(2.25e16),
    meff(0.041),
    np_mass(9.0),
    mu_eff(1.0),
    ksee(0.1),
    B(6.8e-9),
    dqm0(4.6e-9),
    eps(13.6),
    theta(2.5),
    beta(1.55),
    nd(0.0)
{
  // Set params to constant default values (from parTable):
  setDefaultParams();

  // Set params according to .model line and constant defaults from metadata:
  setModParams(model_block.params);

  if (!given("XYCEADMSMODTEMP"))
    admsModTemp=getDeviceOptions().temp.getImmutableValue<double>();

  // Calculate any parameters specified as expressions:

  updateDependentParameters();

  // calculate dependent (ie computed) params and check for errors:
  processParams();
}

//-----------------------------------------------------------------------------
// Function      : Model::~Model
// Purpose       : destructor
// Special Notes :
// Scope         : public
// Creator       :
// Creation Date :
//-----------------------------------------------------------------------------
Model::~Model()
{
  std::vector<Instance*>::iterator iterI;
  std::vector<Instance*>::iterator firstI = instanceContainer.begin ();
  std::vector<Instance*>::iterator lastI  = instanceContainer.end ();

  // loop over instances:
  for (iterI = firstI; iterI != lastI; ++iterI)
  {
    delete (*iterI);
  }
}

//-----------------------------------------------------------------------------
// Function      : Model::printOutInstances
// Purpose       : debugging tool.
// Special Notes :
// Scope         : public
// Creator       :
// Creation Date :
//-----------------------------------------------------------------------------
std::ostream &Model::printOutInstances(std::ostream &os) const
{
  std::vector<Instance*>::const_iterator iter;
  std::vector<Instance*>::const_iterator first = instanceContainer.begin();
  std::vector<Instance*>::const_iterator last  = instanceContainer.end();

  int i;
  os << std::endl;
  os << "    name     model name  Parameters" << std::endl;
  for (i=0, iter=first; iter!=last; ++iter, ++i)
  {
    os << "  " << i << ": " << (*iter)->getName() << "      ";
    os << getName();

    os << std::endl;
    os << std::endl;
  }

  os << std::endl;

  return os;
}

//-----------------------------------------------------------------------------
// Function      : Model::forEachInstance
// Purpose       :
// Special Notes :
// Scope         : public
// Creator       : David Baur
// Creation Date : 2/4/2014
//-----------------------------------------------------------------------------
/// Apply a device instance "op" to all instances associated with this
/// model
///
/// @param[in] op Operator to apply to all instances.
///
///
void Model::forEachInstance(DeviceInstanceOp &op) const
{
  for (std::vector<Instance *>::const_iterator it = instanceContainer.begin(); it != instanceContainer.end(); ++it)
    op(*it);
}

Device *Traits::factory(const Configuration &configuration, const FactoryBlock &factory_block)
{
  return new DeviceMaster<Traits>(configuration, factory_block, factory_block.solverState_, factory_block.deviceOptions_);
}

void
registerDevice(const DeviceCountMap& deviceMap, const std::set<int>& levelSet)
{
  if (deviceMap.empty() ||
      ((deviceMap.find("M") != deviceMap.end() && (levelSet.find(2001)!=levelSet.end()))))
  {
    MOSFET1::registerDevice();
    Config<Traits>::addConfiguration()
      .registerDevice("m", 2001)
      .registerModelType("nmos", 2001)
      .registerModelType("pmos", 2001);
  }
}



#ifdef Xyce_ADMS_SENSITIVITIES
//-----------------------------------------------------------------------------
// Function      : evaluateInitialInstance
// Purpose       : Evaluate the statements in the initial_instance block
// Special Notes : specific for sensitivity use
// Scope         : public
// Creator       : admsXml
// Creation Date :
//-----------------------------------------------------------------------------
void evaluateInitialInstance(
   // model parameters
   // reals
   AdmsSensFadType & modelPar_version,
   bool modelPar_given_version,
   AdmsSensFadType & modelPar_W,
   bool modelPar_given_W,
   AdmsSensFadType & modelPar_Lgdr,
   bool modelPar_given_Lgdr,
   AdmsSensFadType & modelPar_dLg,
   bool modelPar_given_dLg,
   AdmsSensFadType & modelPar_Cins,
   bool modelPar_given_Cins,
   AdmsSensFadType & modelPar_Tjun,
   bool modelPar_given_Tjun,
   AdmsSensFadType & modelPar_energy_diff_volt,
   bool modelPar_given_energy_diff_volt,
   AdmsSensFadType & modelPar_delta,
   bool modelPar_given_delta,
   AdmsSensFadType & modelPar_n0,
   bool modelPar_given_n0,
   AdmsSensFadType & modelPar_Rc0,
   bool modelPar_given_Rc0,
   AdmsSensFadType & modelPar_nacc,
   bool modelPar_given_nacc,
   AdmsSensFadType & modelPar_meff,
   bool modelPar_given_meff,
   AdmsSensFadType & modelPar_np_mass,
   bool modelPar_given_np_mass,
   AdmsSensFadType & modelPar_mu_eff,
   bool modelPar_given_mu_eff,
   AdmsSensFadType & modelPar_ksee,
   bool modelPar_given_ksee,
   AdmsSensFadType & modelPar_B,
   bool modelPar_given_B,
   AdmsSensFadType & modelPar_dqm0,
   bool modelPar_given_dqm0,
   AdmsSensFadType & modelPar_eps,
   bool modelPar_given_eps,
   AdmsSensFadType & modelPar_theta,
   bool modelPar_given_theta,
   AdmsSensFadType & modelPar_beta,
   bool modelPar_given_beta,
   AdmsSensFadType & modelPar_nd,
   bool modelPar_given_nd,
   // non-reals (including hidden)
   int modelPar_type,
   bool modelPar_given_type,
   double admsTemperature, double adms_vt_nom, double ADMSgmin_arg, const Instance & theInstance)
{
}



//-----------------------------------------------------------------------------
// Function      : evaluateInitialModel
// Purpose       : Evaluate the statements in the initial_model block
// Special Notes : specific for sensitivity use
// Scope         : public
// Creator       : admsXml
// Creation Date :
//-----------------------------------------------------------------------------
void evaluateInitialModel(
   // model parameters
   // reals
   AdmsSensFadType & modelPar_version,
   bool modelPar_given_version,
   AdmsSensFadType & modelPar_W,
   bool modelPar_given_W,
   AdmsSensFadType & modelPar_Lgdr,
   bool modelPar_given_Lgdr,
   AdmsSensFadType & modelPar_dLg,
   bool modelPar_given_dLg,
   AdmsSensFadType & modelPar_Cins,
   bool modelPar_given_Cins,
   AdmsSensFadType & modelPar_Tjun,
   bool modelPar_given_Tjun,
   AdmsSensFadType & modelPar_energy_diff_volt,
   bool modelPar_given_energy_diff_volt,
   AdmsSensFadType & modelPar_delta,
   bool modelPar_given_delta,
   AdmsSensFadType & modelPar_n0,
   bool modelPar_given_n0,
   AdmsSensFadType & modelPar_Rc0,
   bool modelPar_given_Rc0,
   AdmsSensFadType & modelPar_nacc,
   bool modelPar_given_nacc,
   AdmsSensFadType & modelPar_meff,
   bool modelPar_given_meff,
   AdmsSensFadType & modelPar_np_mass,
   bool modelPar_given_np_mass,
   AdmsSensFadType & modelPar_mu_eff,
   bool modelPar_given_mu_eff,
   AdmsSensFadType & modelPar_ksee,
   bool modelPar_given_ksee,
   AdmsSensFadType & modelPar_B,
   bool modelPar_given_B,
   AdmsSensFadType & modelPar_dqm0,
   bool modelPar_given_dqm0,
   AdmsSensFadType & modelPar_eps,
   bool modelPar_given_eps,
   AdmsSensFadType & modelPar_theta,
   bool modelPar_given_theta,
   AdmsSensFadType & modelPar_beta,
   bool modelPar_given_beta,
   AdmsSensFadType & modelPar_nd,
   bool modelPar_given_nd,
   // non-reals (including hidden)
   int modelPar_type,
   bool modelPar_given_type,
   double admsTemperature, double ADMSgmin_arg, const Instance & theInstance)
{
}



//-----------------------------------------------------------------------------
// Function      : evaluateModelEquations
// Purpose       : Evaluate the main module block.  Similar to
//                 updateIntermediateVars, but takes all instance and model
//                 parameters and variables as arguments instead of using
//                 the ones stored in the objects.
// Special Notes : specific for sensitivity use
// Scope         : public
// Creator       : admsXml
// Creation Date :
//-----------------------------------------------------------------------------
void evaluateModelEquations(
   std::vector <double> & probeVars,
   // probe constants
   const int admsProbeID_V_sf_GND,
   const int admsProbeID_V_s_GND,
   const int admsProbeID_V_d_GND,
   const int admsProbeID_V_di_GND,
   const int admsProbeID_V_si_GND,
   const int admsProbeID_V_g_GND,
   const int admsProbeID_I_sf_GND,
   // node constants
   const int admsNodeID_d,
   const int admsNodeID_g,
   const int admsNodeID_s,
   const int admsNodeID_di,
   const int admsNodeID_si,
   const int admsNodeID_sf,
   const int admsBRA_ID_sf_GND,
   // model parameters
   // reals
   AdmsSensFadType & modelPar_version,
   bool modelPar_given_version,
   AdmsSensFadType & modelPar_W,
   bool modelPar_given_W,
   AdmsSensFadType & modelPar_Lgdr,
   bool modelPar_given_Lgdr,
   AdmsSensFadType & modelPar_dLg,
   bool modelPar_given_dLg,
   AdmsSensFadType & modelPar_Cins,
   bool modelPar_given_Cins,
   AdmsSensFadType & modelPar_Tjun,
   bool modelPar_given_Tjun,
   AdmsSensFadType & modelPar_energy_diff_volt,
   bool modelPar_given_energy_diff_volt,
   AdmsSensFadType & modelPar_delta,
   bool modelPar_given_delta,
   AdmsSensFadType & modelPar_n0,
   bool modelPar_given_n0,
   AdmsSensFadType & modelPar_Rc0,
   bool modelPar_given_Rc0,
   AdmsSensFadType & modelPar_nacc,
   bool modelPar_given_nacc,
   AdmsSensFadType & modelPar_meff,
   bool modelPar_given_meff,
   AdmsSensFadType & modelPar_np_mass,
   bool modelPar_given_np_mass,
   AdmsSensFadType & modelPar_mu_eff,
   bool modelPar_given_mu_eff,
   AdmsSensFadType & modelPar_ksee,
   bool modelPar_given_ksee,
   AdmsSensFadType & modelPar_B,
   bool modelPar_given_B,
   AdmsSensFadType & modelPar_dqm0,
   bool modelPar_given_dqm0,
   AdmsSensFadType & modelPar_eps,
   bool modelPar_given_eps,
   AdmsSensFadType & modelPar_theta,
   bool modelPar_given_theta,
   AdmsSensFadType & modelPar_beta,
   bool modelPar_given_beta,
   AdmsSensFadType & modelPar_nd,
   bool modelPar_given_nd,
   // non-reals (including hidden)
   int modelPar_type,
   bool modelPar_given_type,
   // basic variables
   double admsTemperature, double adms_vt_nom, double ADMSgmin_arg, std::vector <AdmsSensFadType> & staticContributions, std::vector <AdmsSensFadType> & dynamicContributions, const Instance & theInstance)
{

  // Local variables
  AdmsSensFadType Rd;
  AdmsSensFadType Rs;
  AdmsSensFadType Idsatbeta;
  AdmsSensFadType Id_sat;
  AdmsSensFadType Qacc;
  AdmsSensFadType Id;
  AdmsSensFadType vx0;
  AdmsSensFadType Fsat;
  AdmsSensFadType Vdsatbeta;
  AdmsSensFadType Vdsat;
  AdmsSensFadType f1;
  AdmsSensFadType n;
  AdmsSensFadType Cgc;
  AdmsSensFadType Cstern;
  AdmsSensFadType xav;
  AdmsSensFadType QB;
  AdmsSensFadType Qx0;
  AdmsSensFadType Tx;
  AdmsSensFadType Lcrit;
  AdmsSensFadType Lcrit_sat;
  AdmsSensFadType Lcrit_lin;
  AdmsSensFadType f2;
  AdmsSensFadType Vdsatbeta2;
  AdmsSensFadType Vdsat2;
  AdmsSensFadType vT_acc;
  AdmsSensFadType extr_coef_acc;
  AdmsSensFadType FDhalfs_acc;
  AdmsSensFadType c1_acc;
  AdmsSensFadType den1_acc;
  AdmsSensFadType A1_acc;
  AdmsSensFadType expMeta_acc;
  AdmsSensFadType expu_acc;
  AdmsSensFadType exp_eta_acc;
  AdmsSensFadType eta_acc;
  AdmsSensFadType vT;
  AdmsSensFadType lambda;
  AdmsSensFadType dgen_lambda;
  AdmsSensFadType FDminushalfs;
  AdmsSensFadType t2_fd1;
  AdmsSensFadType den_t1_fd1;
  AdmsSensFadType aterm1;
  double num_t1_fd1;
  double c_pow1;
  double b_pow1;
  double a_pow1;
  double j_pow1;
  AdmsSensFadType u1;
  AdmsSensFadType extr_coef;
  AdmsSensFadType FDhalfs;
  AdmsSensFadType c1;
  AdmsSensFadType den1;
  AdmsSensFadType A1;
  AdmsSensFadType expMeta;
  AdmsSensFadType NP_fac_velocity;
  AdmsSensFadType NP_fac_lambda;
  AdmsSensFadType meff_np;
  AdmsSensFadType Fd;
  AdmsSensFadType Ed_sq;
  AdmsSensFadType ffd;
  AdmsSensFadType expEd;
  double sign_Ed;
  AdmsSensFadType Ed;
  AdmsSensFadType Fs;
  AdmsSensFadType Es_sq;
  AdmsSensFadType ffs;
  AdmsSensFadType expEs;
  double sign_Es;
  AdmsSensFadType Es;
  AdmsSensFadType N2D;
  AdmsSensFadType lambda_int;
  AdmsSensFadType vT_int;
  AdmsSensFadType mD0;
  double sqrt_pi;
  double hbar;
  AdmsSensFadType kT;
  AdmsSensFadType phit;
  AdmsSensFadType Rc;
  AdmsSensFadType Leff;
  double dir;
  AdmsSensFadType Vgsi;
  AdmsSensFadType Vdsi;
  AdmsSensFadType Vgs;
  AdmsSensFadType Vds;
  AdmsSensFadType Vgdraw;
  AdmsSensFadType Vgsraw;


  // -- code converted from analog/code block
  Vgsraw = (modelPar_type*((probeVars[admsProbeID_V_g_GND])-(probeVars[admsProbeID_V_si_GND])));
  Vgdraw = (modelPar_type*((probeVars[admsProbeID_V_g_GND])-(probeVars[admsProbeID_V_di_GND])));
  if ((Vgsraw>=Vgdraw))
  {
    Vds = (modelPar_type*((probeVars[admsProbeID_V_d_GND])-(probeVars[admsProbeID_V_s_GND])));
    Vgs = (modelPar_type*((probeVars[admsProbeID_V_g_GND])-(probeVars[admsProbeID_V_s_GND])));
    Vdsi = (modelPar_type*((probeVars[admsProbeID_V_di_GND])-(probeVars[admsProbeID_V_si_GND])));
    Vgsi = Vgsraw;
    dir = 1;
  }
  else
  {
    Vds = (modelPar_type*((probeVars[admsProbeID_V_s_GND])-(probeVars[admsProbeID_V_d_GND])));
    Vgs = (modelPar_type*((probeVars[admsProbeID_V_g_GND])-(probeVars[admsProbeID_V_d_GND])));
    Vdsi = (modelPar_type*((probeVars[admsProbeID_V_si_GND])-(probeVars[admsProbeID_V_di_GND])));
    Vgsi = Vgdraw;
    dir = (-1);
  }
  Leff = (modelPar_Lgdr-modelPar_dLg);
  Rc = (modelPar_Rc0/modelPar_W);
  phit = ((1.3806503e-23*modelPar_Tjun)/1.6021766208e-19);
  kT = (1.3806503e-23*modelPar_Tjun);
  hbar = (6.62607004081e-34/(2.0*3.14159265358979323846));
  {
    double value_sqrt_0 = sqrt(static_cast<double>(3.14159265358979323846));
    sqrt_pi = value_sqrt_0;
  }
  mD0 = (modelPar_meff*9.10938215e-31);
  {
    AdmsSensFadType value_sqrt_0 = sqrt(((((2.0*kT)/3.14159265358979323846)*1.0)/mD0));
    vT_int = value_sqrt_0;
  }
  lambda_int = (((2.0*phit)*modelPar_mu_eff)/vT_int);
  N2D = ((mD0/((3.14159265358979323846*hbar)*hbar))*kT);
  Es = ((modelPar_energy_diff_volt+(probeVars[admsProbeID_V_sf_GND]))/phit);
  if ((Es>0))
  {
    sign_Es = 1.0;
  }
  else
  {
    if ((Es==0))
    {
      sign_Es = 0;
    }
    else
    {
      if ((Es<0))
      {
        sign_Es = (-1.0);
      }
    }
  }
  {
    AdmsSensFadType value_exp_0 = exp(Es);
    expEs = value_exp_0;
  }
  if ((Es>=40))
  {
    ffs = 0;
  }
  else
  {
    ffs = (1.0/(1.0+(expEs*0.6)));
  }
  Es_sq = ((((1.0+sign_Es)*Es)*Es)/4.0);
  {
    AdmsSensFadType value_log_0 = log((1.0+expEs));
    Fs = (value_log_0+((modelPar_np_mass*phit)*((ffs*expEs)+((1-ffs)*Es_sq))));
  }
  Ed = (((modelPar_energy_diff_volt+(probeVars[admsProbeID_V_sf_GND]))-Vdsi)/phit);
  if ((Ed>0))
  {
    sign_Ed = 1.0;
  }
  else
  {
    if ((Ed==0))
    {
      sign_Ed = 0;
    }
    else
    {
      if ((Ed<0))
      {
        sign_Ed = (-1.0);
      }
    }
  }
  {
    AdmsSensFadType value_exp_0 = exp(Ed);
    expEd = value_exp_0;
  }
  if ((Ed>=40))
  {
    ffd = 0;
  }
  else
  {
    ffd = (1.0/(1.0+(expEd*0.6)));
  }
  Ed_sq = ((((1.0+sign_Ed)*Ed)*Ed)/4.0);
  {
    AdmsSensFadType value_log_0 = log((1.0+expEd));
    Fd = (value_log_0+((modelPar_np_mass*phit)*((ffd*expEd)+((1.0-ffd)*Ed_sq))));
  }
  if ((Es>=40))
  {
    meff_np = (Fs/expEs);
  }
  else
  {
    {
      AdmsSensFadType value_log_0 = log((1.0+expEs));
      meff_np = (Fs/value_log_0);
    }
  }
  {
    AdmsSensFadType value_sqrt_0 = sqrt(meff_np);
    NP_fac_lambda = value_sqrt_0;
  }
  NP_fac_velocity = (1.0/NP_fac_lambda);
  expMeta = (1.0/expEs);
  {
    AdmsSensFadType value_pow_0 = pow(Es,4.0);
    AdmsSensFadType value_exp_1 = exp((((-0.17)*(1.0+Es))*(1.0+Es)));
    A1 = ((50.0+value_pow_0)+((33.6*Es)*(1-(0.68*value_exp_1))));
  }
  {
    AdmsSensFadType value_pow_0 = pow(A1,(3.0/8.0));
    den1 = value_pow_0;
  }
  c1 = (((3.0/4.0)*sqrt_pi)/den1);
  FDhalfs = (1.0/(c1+expMeta));
  {
    AdmsSensFadType value_log_0 = log((1.0+expEs));
    extr_coef = (FDhalfs/value_log_0);
  }
  u1 = Es;
  j_pow1 = (-0.5);
  {
    double value_sqrt_0 = sqrt(((1.0+((15.0/4.0)*(j_pow1+1.0)))+(((1.0/40.0)*(j_pow1+1.0))*(j_pow1+1.0))));
    a_pow1 = value_sqrt_0;
  }
  b_pow1 = (1.8+(0.61*j_pow1));
  {
    double value_sqrt_0 = sqrt(static_cast<double>(2.0));
    double value_pow_1 = pow(2.0,(-j_pow1));
    c_pow1 = (2.0+((2.0-value_sqrt_0)*value_pow_1));
  }
  {
    double value_pow_0 = pow(2.0,(1.0+j_pow1));
    num_t1_fd1 = ((j_pow1+1.0)*value_pow_0);
  }
  {
    AdmsSensFadType value_pow_0 = pow(a_pow1,c_pow1);
    AdmsSensFadType value_fabs_1 = fabs((u1-b_pow1));
    AdmsSensFadType value_pow_2 = pow(value_fabs_1,c_pow1);
    AdmsSensFadType value_pow_3 = pow((((b_pow1+u1)+value_pow_0)+value_pow_2),(1.0/c_pow1));
    aterm1 = value_pow_3;
  }
  {
    AdmsSensFadType value_pow_0 = pow(aterm1,(1.0+j_pow1));
    den_t1_fd1 = value_pow_0;
  }
  {
    AdmsSensFadType value_exp_0 = exp((-u1));
    AdmsSensFadType value_sqrt_1 = sqrt(static_cast<double>(3.14159265358979323846));
    t2_fd1 = (value_exp_0/value_sqrt_1);
  }
  {
    AdmsSensFadType value_sqrt_0 = sqrt(static_cast<double>(3.14159265358979323846));
    AdmsSensFadType value_pow_1 = pow(((num_t1_fd1/den_t1_fd1)+t2_fd1),(-1.0));
    FDminushalfs = ((1.0/value_sqrt_0)*value_pow_1);
  }
  {
    AdmsSensFadType value_log_0 = log((1.0+expEs));
    dgen_lambda = (value_log_0/FDminushalfs);
  }
  lambda = ((lambda_int*NP_fac_lambda)*dgen_lambda);
  vT = ((vT_int*NP_fac_velocity)*extr_coef);
  {
    AdmsSensFadType value_exp_0 = exp((modelPar_nacc/N2D));
    AdmsSensFadType value_log_1 = log((value_exp_0-1.0));
    eta_acc = value_log_1;
  }
  {
    AdmsSensFadType value_exp_0 = exp((modelPar_nacc/N2D));
    exp_eta_acc = (value_exp_0-1.0);
  }
  expu_acc = exp_eta_acc;
  expMeta_acc = (1.0/expu_acc);
  {
    AdmsSensFadType value_pow_0 = pow(eta_acc,4.0);
    AdmsSensFadType value_exp_1 = exp((((-0.17)*(1.0+eta_acc))*(1.0+eta_acc)));
    A1_acc = ((50.0+value_pow_0)+((33.6*eta_acc)*(1-(0.68*value_exp_1))));
  }
  {
    AdmsSensFadType value_pow_0 = pow(A1_acc,(3.0/8.0));
    den1_acc = value_pow_0;
  }
  c1_acc = (((3.0/4.0)*sqrt_pi)/den1_acc);
  FDhalfs_acc = (1.0/(c1_acc+expMeta_acc));
  {
    AdmsSensFadType value_log_0 = log((1.0+exp_eta_acc));
    extr_coef_acc = (FDhalfs_acc/value_log_0);
  }
  vT_acc = (vT_int*extr_coef_acc);
  Vdsat2 = (modelPar_theta*phit);
  {
    AdmsSensFadType value_fabs_0 = fabs((Vdsi/Vdsat2));
    AdmsSensFadType value_pow_1 = pow(value_fabs_0,modelPar_beta);
    Vdsatbeta2 = value_pow_1;
  }
  {
    AdmsSensFadType value_fabs_0 = fabs((Vdsi/Vdsat2));
    AdmsSensFadType value_pow_1 = pow((1.0+Vdsatbeta2),(1.0/modelPar_beta));
    f2 = (value_fabs_0/value_pow_1);
  }
  Lcrit_lin = Leff;
  Lcrit_sat = (modelPar_ksee*Leff);
  Lcrit = (((1.0-f2)*Lcrit_lin)+(f2*Lcrit_sat));
  Tx = (lambda/(lambda+Lcrit));
  Qx0 = ((((-1.6021766208e-19)*N2D)/2.0)*((Fs*(2.0-Tx))+(Fd*Tx)));
  {
    AdmsSensFadType value_fabs_0 = fabs((modelPar_B/modelPar_dqm0));
    AdmsSensFadType value_pow_1 = pow(value_fabs_0,3.0);
    QB = value_pow_1;
  }
  {
    AdmsSensFadType value_fabs_0 = fabs(Qx0);
    AdmsSensFadType value_pow_1 = pow((QB+((11.0/32.0)*value_fabs_0)),(1/3.0));
    xav = (modelPar_B/value_pow_1);
  }
  Cstern = ((modelPar_eps*8.854187817e-12)/xav);
  Cgc = ((modelPar_Cins*Cstern)/(modelPar_Cins+Cstern));
  {
    AdmsSensFadType value_fabs_0 = fabs((modelPar_nd*Vdsi));
    n = (modelPar_n0+value_fabs_0);
  }
  // V(sf,GND) <+ ((((Vgsi+(delta*Vdsi))+(Qx0/Cgc))/n))
  staticContributions[admsBRA_ID_sf_GND] += (((Vgsi+(modelPar_delta*Vdsi))+(Qx0/Cgc))/n);
  f1 = ((((2.0-Tx)*Fs)+(Tx*Fd))/(2.0*Fs));
  Vdsat = ((((2.0*phit)*(lambda+Leff))/(lambda+((2.0*modelPar_ksee)*Leff)))*f1);
  {
    AdmsSensFadType value_fabs_0 = fabs((Vdsi/Vdsat));
    AdmsSensFadType value_pow_1 = pow(value_fabs_0,modelPar_beta);
    Vdsatbeta = value_pow_1;
  }
  {
    AdmsSensFadType value_fabs_0 = fabs((Vdsi/Vdsat));
    AdmsSensFadType value_pow_1 = pow((1.0+Vdsatbeta),(1.0/modelPar_beta));
    Fsat = (value_fabs_0/value_pow_1);
  }
  vx0 = ((vT*lambda)/(lambda+((2.0*modelPar_ksee)*Leff)));
  {
    AdmsSensFadType value_fabs_0 = fabs(Qx0);
    Id = (((value_fabs_0*Fsat)*vx0)*modelPar_W);
  }
  Qacc = (1.6021766208e-19*modelPar_nacc);
  Id_sat = ((modelPar_W*Qacc)*vT_acc);
  {
    AdmsSensFadType value_fabs_0 = fabs((Id/Id_sat));
    AdmsSensFadType value_pow_1 = pow(value_fabs_0,modelPar_beta);
    Idsatbeta = value_pow_1;
  }
  {
    AdmsSensFadType value_pow_0 = pow((1-Idsatbeta),(1.0/modelPar_beta));
    Rs = (Rc/value_pow_0);
  }
  Rd = Rs;
  // I(di,si) <+ (((type*dir)*Id))
  staticContributions[admsNodeID_di] += ((modelPar_type*dir)*Id);
  staticContributions[admsNodeID_si] -= ((modelPar_type*dir)*Id);
  // I(d,di) <+ (((V(d,GND)-V(di,GND))/Rd))
  staticContributions[admsNodeID_d] += (((probeVars[admsProbeID_V_d_GND])-(probeVars[admsProbeID_V_di_GND]))/Rd);
  staticContributions[admsNodeID_di] -= (((probeVars[admsProbeID_V_d_GND])-(probeVars[admsProbeID_V_di_GND]))/Rd);
  // I(si,s) <+ (((V(si,GND)-V(s,GND))/Rs))
  staticContributions[admsNodeID_si] += (((probeVars[admsProbeID_V_si_GND])-(probeVars[admsProbeID_V_s_GND]))/Rs);
  staticContributions[admsNodeID_s] -= (((probeVars[admsProbeID_V_si_GND])-(probeVars[admsProbeID_V_s_GND]))/Rs);
}



//-----------------------------------------------------------------------------
// Function      : InstanceSensitivity::operator()
// Purpose       : return sensitivity for a single instance parameter
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
//-----------------------------------------------------------------------------
/// Compute sensitivity of a device instance's outputs to a specified instance
/// parameter
///
///
/// @param[in] entity  The device entity that owns the parameter
/// @param[in] name    The unadorned parameter name specific to the entity
/// @param[out] dfdp   The derivative of the F vector with respect to the parameter
/// @param[out] dqdp   The derivative of the Q vector with respect to the parameter
/// @param[out] dbdp   The derivative of the B vector with respect to the parameter
/// @param[out] Findices   The indices into the F vector corresponding to the elements of dfdp
/// @param[out] Qindices   The indices into the Q vector corresponding to the elements of dfdp
/// @param[out] Bindices   The indices into the B vector corresponding to the elements of dfdp
///
///
void InstanceSensitivity::operator()
  (
     const ParameterBase &entity,
     const std::string &name,
     std::vector<double> & dfdp,
     std::vector<double> & dqdp,
     std::vector<double> & dbdp,
     std::vector<int> & Findices,
     std::vector<int> & Qindices,
     std::vector<int> & Bindices
   ) const
{
  const ParameterBase * e1 = &entity;
  const Instance & in = *(dynamic_cast<const Instance *> (e1));
  const Model & mod =in.model_;

  dfdp.resize(6+1);
  dqdp.resize(6+1);
  Findices.resize(6+1);
  Qindices.resize(6+1);

  std::vector <double> probeVars(7);
  std::vector <AdmsSensFadType> staticContributions(6+1);
  std::vector <AdmsSensFadType> dynamicContributions(6+1);


  // initialize contributions to zero (automatically sets derivatives to zero)
  for (int i=0; i < 6+1 ; ++i)
  {
    staticContributions[i]=0;
    dynamicContributions[i]=0;
  }

  // Copy out all the model parameters (doubles) into FAD types
  //reals
  AdmsSensFadType modelPar_version=mod.version;
  bool modelPar_given_version=mod.given("version");
  AdmsSensFadType modelPar_W=mod.W;
  bool modelPar_given_W=mod.given("W");
  AdmsSensFadType modelPar_Lgdr=mod.Lgdr;
  bool modelPar_given_Lgdr=mod.given("Lgdr");
  AdmsSensFadType modelPar_dLg=mod.dLg;
  bool modelPar_given_dLg=mod.given("dLg");
  AdmsSensFadType modelPar_Cins=mod.Cins;
  bool modelPar_given_Cins=mod.given("Cins");
  AdmsSensFadType modelPar_Tjun=mod.Tjun;
  bool modelPar_given_Tjun=mod.given("Tjun");
  AdmsSensFadType modelPar_energy_diff_volt=mod.energy_diff_volt;
  bool modelPar_given_energy_diff_volt=mod.given("energy_diff_volt");
  AdmsSensFadType modelPar_delta=mod.delta;
  bool modelPar_given_delta=mod.given("delta");
  AdmsSensFadType modelPar_n0=mod.n0;
  bool modelPar_given_n0=mod.given("n0");
  AdmsSensFadType modelPar_Rc0=mod.Rc0;
  bool modelPar_given_Rc0=mod.given("Rc0");
  AdmsSensFadType modelPar_nacc=mod.nacc;
  bool modelPar_given_nacc=mod.given("nacc");
  AdmsSensFadType modelPar_meff=mod.meff;
  bool modelPar_given_meff=mod.given("meff");
  AdmsSensFadType modelPar_np_mass=mod.np_mass;
  bool modelPar_given_np_mass=mod.given("np_mass");
  AdmsSensFadType modelPar_mu_eff=mod.mu_eff;
  bool modelPar_given_mu_eff=mod.given("mu_eff");
  AdmsSensFadType modelPar_ksee=mod.ksee;
  bool modelPar_given_ksee=mod.given("ksee");
  AdmsSensFadType modelPar_B=mod.B;
  bool modelPar_given_B=mod.given("B");
  AdmsSensFadType modelPar_dqm0=mod.dqm0;
  bool modelPar_given_dqm0=mod.given("dqm0");
  AdmsSensFadType modelPar_eps=mod.eps;
  bool modelPar_given_eps=mod.given("eps");
  AdmsSensFadType modelPar_theta=mod.theta;
  bool modelPar_given_theta=mod.given("theta");
  AdmsSensFadType modelPar_beta=mod.beta;
  bool modelPar_given_beta=mod.given("beta");
  AdmsSensFadType modelPar_nd=mod.nd;
  bool modelPar_given_nd=mod.given("nd");


  // hidden reals


  // non-reals (including hiddens)
  int modelPar_type=mod.type;
  bool modelPar_given_type=mod.given("type");



  // Copy out all the instance parameters (doubles) into FAD types
  // Keep a map so we can set the right one to the independent variable
  // We do this solely to avoid a big ugly "if/else" block just to find the
  // one parameter we're doing sensitivities on.
  unordered_map <std::string,AdmsSensFadType*,HashNoCase,EqualNoCase> inParamMap;

  // reals


  // Copy all the real hidden instance params into fad types



  // Copy all the non-real instance params into vars of their appropriate type:


  // Set the one parameter whose name was passed in to be the independent
  // variable for Sacado purposes.  Since we stored variable pointers, this
  // makes sure that that ONE variable gets set right.
  // FIXME: make this check the name first, otherwise segfault on invalid name!
  inParamMap[name]->diff(0,1);

  //make local copies of all instance vars
  //reals


  //non-reals


  //make local copies of all model vars
  //reals


  // non-reals



  Linear::Vector * solVectorPtr = in.extData.nextSolVectorPtr;

  // extract solution variables and set as Fad independent variables.
  probeVars[in.admsProbeID_V_sf_GND] = (*solVectorPtr)[in.li_sf];
  probeVars[in.admsProbeID_V_s_GND] = (*solVectorPtr)[in.li_s];
  probeVars[in.admsProbeID_V_d_GND] = (*solVectorPtr)[in.li_d];
  probeVars[in.admsProbeID_V_di_GND] = (*solVectorPtr)[in.li_di];
  probeVars[in.admsProbeID_V_si_GND] = (*solVectorPtr)[in.li_si];
  probeVars[in.admsProbeID_V_g_GND] = (*solVectorPtr)[in.li_g];

  probeVars[in.admsProbeID_I_sf_GND] = (*solVectorPtr)[in.li_BRA_sf_GND];



  // Now call  the function that does the heavy lifting.
  evaluateModelEquations(
     probeVars,
     // probe constants
     in.admsProbeID_V_sf_GND,
     in.admsProbeID_V_s_GND,
     in.admsProbeID_V_d_GND,
     in.admsProbeID_V_di_GND,
     in.admsProbeID_V_si_GND,
     in.admsProbeID_V_g_GND,
     in.admsProbeID_I_sf_GND,

     // node constants
     in.admsNodeID_d,
     in.admsNodeID_g,
     in.admsNodeID_s,
     in.admsNodeID_di,
     in.admsNodeID_si,
     in.admsNodeID_sf,
     in.admsBRA_ID_sf_GND,
     // model parameters
     // reals
     modelPar_version,
     modelPar_given_version,
     modelPar_W,
     modelPar_given_W,
     modelPar_Lgdr,
     modelPar_given_Lgdr,
     modelPar_dLg,
     modelPar_given_dLg,
     modelPar_Cins,
     modelPar_given_Cins,
     modelPar_Tjun,
     modelPar_given_Tjun,
     modelPar_energy_diff_volt,
     modelPar_given_energy_diff_volt,
     modelPar_delta,
     modelPar_given_delta,
     modelPar_n0,
     modelPar_given_n0,
     modelPar_Rc0,
     modelPar_given_Rc0,
     modelPar_nacc,
     modelPar_given_nacc,
     modelPar_meff,
     modelPar_given_meff,
     modelPar_np_mass,
     modelPar_given_np_mass,
     modelPar_mu_eff,
     modelPar_given_mu_eff,
     modelPar_ksee,
     modelPar_given_ksee,
     modelPar_B,
     modelPar_given_B,
     modelPar_dqm0,
     modelPar_given_dqm0,
     modelPar_eps,
     modelPar_given_eps,
     modelPar_theta,
     modelPar_given_theta,
     modelPar_beta,
     modelPar_given_beta,
     modelPar_nd,
     modelPar_given_nd,
     // non-reals (including hidden)
     modelPar_type,
     modelPar_given_type,
     in.admsTemperature,
     in.adms_vt_nom,
     in.getDeviceOptions().gmin,
     staticContributions,
     dynamicContributions,
     in);


  // We now have the F and Q vector stuff, populate the dependencies:

  dfdp[in.admsNodeID_d] += staticContributions[in.admsNodeID_d].dx(0);
  dqdp[in.admsNodeID_d] += dynamicContributions[in.admsNodeID_d].dx(0);
  Findices[in.admsNodeID_d] = in.li_d;
  Qindices[in.admsNodeID_d] = in.li_d;
  dfdp[in.admsNodeID_g] += staticContributions[in.admsNodeID_g].dx(0);
  dqdp[in.admsNodeID_g] += dynamicContributions[in.admsNodeID_g].dx(0);
  Findices[in.admsNodeID_g] = in.li_g;
  Qindices[in.admsNodeID_g] = in.li_g;
  dfdp[in.admsNodeID_s] += staticContributions[in.admsNodeID_s].dx(0);
  dqdp[in.admsNodeID_s] += dynamicContributions[in.admsNodeID_s].dx(0);
  Findices[in.admsNodeID_s] = in.li_s;
  Qindices[in.admsNodeID_s] = in.li_s;
  dfdp[in.admsNodeID_di] += staticContributions[in.admsNodeID_di].dx(0);
  dqdp[in.admsNodeID_di] += dynamicContributions[in.admsNodeID_di].dx(0);
  Findices[in.admsNodeID_di] = in.li_di;
  Qindices[in.admsNodeID_di] = in.li_di;
  dfdp[in.admsNodeID_si] += staticContributions[in.admsNodeID_si].dx(0);
  dqdp[in.admsNodeID_si] += dynamicContributions[in.admsNodeID_si].dx(0);
  Findices[in.admsNodeID_si] = in.li_si;
  Qindices[in.admsNodeID_si] = in.li_si;
  dfdp[in.admsNodeID_sf] += staticContributions[in.admsNodeID_sf].dx(0);
  dqdp[in.admsNodeID_sf] += dynamicContributions[in.admsNodeID_sf].dx(0);
  Findices[in.admsNodeID_sf] = in.li_sf;
  Qindices[in.admsNodeID_sf] = in.li_sf;
  dfdp[in.admsBRA_ID_sf_GND] += staticContributions[in.admsBRA_ID_sf_GND].dx(0);
  dqdp[in.admsBRA_ID_sf_GND] += dynamicContributions[in.admsBRA_ID_sf_GND].dx(0);
  Findices[in.admsBRA_ID_sf_GND] = in.li_BRA_sf_GND;
  Qindices[in.admsBRA_ID_sf_GND] = in.li_BRA_sf_GND;


}

//-----------------------------------------------------------------------------
// Function      : ModelSensitivity::operator()
// Purpose       : return sensitivity for a single model parameter
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
//-----------------------------------------------------------------------------
/// Compute sensitivity to a specified model
/// parameter of all device instances of that model's outputs
///
///
/// @param[in] entity  The device entity that owns the parameter
/// @param[in] name    The unadorned parameter name specific to the entity
/// @param[out] dfdp   The derivative of the F vector with respect to the parameter
/// @param[out] dqdp   The derivative of the Q vector with respect to the parameter
/// @param[out] dbdp   The derivative of the B vector with respect to the parameter
/// @param[out] Findices   The indices into the F vector corresponding to the elements of dfdp
/// @param[out] Qindices   The indices into the Q vector corresponding to the elements of dfdp
/// @param[out] Bindices   The indices into the B vector corresponding to the elements of dfdp
///
///
void ModelSensitivity::operator()
  (
     const ParameterBase &entity,
     const std::string &name,
     std::vector<double> & dfdp,
     std::vector<double> & dqdp,
     std::vector<double> & dbdp,
     std::vector<int> & Findices,
     std::vector<int> & Qindices,
     std::vector<int> & Bindices
   ) const
{
  const ParameterBase * e1 = &entity;
  const Model & mod = *(dynamic_cast<const Model *> (e1));
  int sizeInstance = mod.instanceContainer.size();

  dfdp.resize((6+1)*sizeInstance);
  dqdp.resize((6+1)*sizeInstance);
  Findices.resize((6+1)*sizeInstance);
  Qindices.resize((6+1)*sizeInstance);

  std::vector <double> probeVars(7);
  std::vector <AdmsSensFadType> staticContributions(6+1);
  std::vector <AdmsSensFadType> dynamicContributions(6+1);


  // Copy out all the model parameters (doubles) into FAD types
  // Keep a map so we can set the right one to the independent variable
  // We do this solely to avoid a big ugly "if/else" block just to find the
  // one parameter we're doing sensitivities on.
  unordered_map <std::string,AdmsSensFadType*,HashNoCase,EqualNoCase> modParamMap;

  // reals
  AdmsSensFadType modelPar_version=mod.version;
  bool modelPar_given_version=mod.given("version");
  modParamMap["version"] = &modelPar_version;
  AdmsSensFadType modelPar_W=mod.W;
  bool modelPar_given_W=mod.given("W");
  modParamMap["W"] = &modelPar_W;
  AdmsSensFadType modelPar_Lgdr=mod.Lgdr;
  bool modelPar_given_Lgdr=mod.given("Lgdr");
  modParamMap["Lgdr"] = &modelPar_Lgdr;
  AdmsSensFadType modelPar_dLg=mod.dLg;
  bool modelPar_given_dLg=mod.given("dLg");
  modParamMap["dLg"] = &modelPar_dLg;
  AdmsSensFadType modelPar_Cins=mod.Cins;
  bool modelPar_given_Cins=mod.given("Cins");
  modParamMap["Cins"] = &modelPar_Cins;
  AdmsSensFadType modelPar_Tjun=mod.Tjun;
  bool modelPar_given_Tjun=mod.given("Tjun");
  modParamMap["Tjun"] = &modelPar_Tjun;
  AdmsSensFadType modelPar_energy_diff_volt=mod.energy_diff_volt;
  bool modelPar_given_energy_diff_volt=mod.given("energy_diff_volt");
  modParamMap["energy_diff_volt"] = &modelPar_energy_diff_volt;
  AdmsSensFadType modelPar_delta=mod.delta;
  bool modelPar_given_delta=mod.given("delta");
  modParamMap["delta"] = &modelPar_delta;
  AdmsSensFadType modelPar_n0=mod.n0;
  bool modelPar_given_n0=mod.given("n0");
  modParamMap["n0"] = &modelPar_n0;
  AdmsSensFadType modelPar_Rc0=mod.Rc0;
  bool modelPar_given_Rc0=mod.given("Rc0");
  modParamMap["Rc0"] = &modelPar_Rc0;
  AdmsSensFadType modelPar_nacc=mod.nacc;
  bool modelPar_given_nacc=mod.given("nacc");
  modParamMap["nacc"] = &modelPar_nacc;
  AdmsSensFadType modelPar_meff=mod.meff;
  bool modelPar_given_meff=mod.given("meff");
  modParamMap["meff"] = &modelPar_meff;
  AdmsSensFadType modelPar_np_mass=mod.np_mass;
  bool modelPar_given_np_mass=mod.given("np_mass");
  modParamMap["np_mass"] = &modelPar_np_mass;
  AdmsSensFadType modelPar_mu_eff=mod.mu_eff;
  bool modelPar_given_mu_eff=mod.given("mu_eff");
  modParamMap["mu_eff"] = &modelPar_mu_eff;
  AdmsSensFadType modelPar_ksee=mod.ksee;
  bool modelPar_given_ksee=mod.given("ksee");
  modParamMap["ksee"] = &modelPar_ksee;
  AdmsSensFadType modelPar_B=mod.B;
  bool modelPar_given_B=mod.given("B");
  modParamMap["B"] = &modelPar_B;
  AdmsSensFadType modelPar_dqm0=mod.dqm0;
  bool modelPar_given_dqm0=mod.given("dqm0");
  modParamMap["dqm0"] = &modelPar_dqm0;
  AdmsSensFadType modelPar_eps=mod.eps;
  bool modelPar_given_eps=mod.given("eps");
  modParamMap["eps"] = &modelPar_eps;
  AdmsSensFadType modelPar_theta=mod.theta;
  bool modelPar_given_theta=mod.given("theta");
  modParamMap["theta"] = &modelPar_theta;
  AdmsSensFadType modelPar_beta=mod.beta;
  bool modelPar_given_beta=mod.given("beta");
  modParamMap["beta"] = &modelPar_beta;
  AdmsSensFadType modelPar_nd=mod.nd;
  bool modelPar_given_nd=mod.given("nd");
  modParamMap["nd"] = &modelPar_nd;


  // hidden reals


  // non-reals (including hiddens)
  int modelPar_type=mod.type;
  bool modelPar_given_type=mod.given("type");


  // Set the one parameter whose name was passed in to be the independent
  // variable for Sacado purposes.  Since we stored variable pointers, this
  // makes sure that that ONE variable gets set right.
  // FIXME: make this check name for presence first!  Segfault on invalid.
  modParamMap[name]->diff(0,1);

  //make local copies of all model vars
  //reals


  // non-reals



  // Now loop over all instances and do the deed
  int inst=0;
  for (std::vector<Instance*>::const_iterator in_it=mod.instanceContainer.begin(); in_it != mod.instanceContainer.end(); ++in_it,++inst)
  {

    Instance & in=*(*in_it);
    // initialize contributions to zero (automatically sets derivatives to zero)
    for (int i=0; i < 6+1 ; ++i)
    {
      staticContributions[i]=0;
      dynamicContributions[i]=0;
    }



    // Copy out all the instance parameters (doubles) into FAD types
    // reals


    // real hidden instance


    // Copy all the non-real instance params into vars of their appropriate type:




    // If there are any instance parameters that were not given, and have
    // corresponding model params, copy the model param into the instance.
    // This was already done by the instance constructor, but we do it again
    // because now we're propagating derivatives, and the user could be trying
    // to get sensitivity to the model parameter.


    //make local copies of all instance vars
    //reals


    //non-reals



    Linear::Vector * solVectorPtr = in.extData.nextSolVectorPtr;

    // extract solution variables and set as Fad independent variables.
    probeVars[in.admsProbeID_V_sf_GND] = (*solVectorPtr)[in.li_sf];
    probeVars[in.admsProbeID_V_s_GND] = (*solVectorPtr)[in.li_s];
    probeVars[in.admsProbeID_V_d_GND] = (*solVectorPtr)[in.li_d];
    probeVars[in.admsProbeID_V_di_GND] = (*solVectorPtr)[in.li_di];
    probeVars[in.admsProbeID_V_si_GND] = (*solVectorPtr)[in.li_si];
    probeVars[in.admsProbeID_V_g_GND] = (*solVectorPtr)[in.li_g];
    probeVars[in.admsProbeID_I_sf_GND] = (*solVectorPtr)[in.li_BRA_sf_GND];




    // Now call  the function that does the heavy lifting.

    evaluateModelEquations(
       probeVars,
       // probe constants
       in.admsProbeID_V_sf_GND,
       in.admsProbeID_V_s_GND,
       in.admsProbeID_V_d_GND,
       in.admsProbeID_V_di_GND,
       in.admsProbeID_V_si_GND,
       in.admsProbeID_V_g_GND,
       in.admsProbeID_I_sf_GND,

       // node constants
       in.admsNodeID_d,
       in.admsNodeID_g,
       in.admsNodeID_s,
       in.admsNodeID_di,
       in.admsNodeID_si,
       in.admsNodeID_sf,
       in.admsBRA_ID_sf_GND,
       // model parameters
       // reals
       modelPar_version,
       modelPar_given_version,
       modelPar_W,
       modelPar_given_W,
       modelPar_Lgdr,
       modelPar_given_Lgdr,
       modelPar_dLg,
       modelPar_given_dLg,
       modelPar_Cins,
       modelPar_given_Cins,
       modelPar_Tjun,
       modelPar_given_Tjun,
       modelPar_energy_diff_volt,
       modelPar_given_energy_diff_volt,
       modelPar_delta,
       modelPar_given_delta,
       modelPar_n0,
       modelPar_given_n0,
       modelPar_Rc0,
       modelPar_given_Rc0,
       modelPar_nacc,
       modelPar_given_nacc,
       modelPar_meff,
       modelPar_given_meff,
       modelPar_np_mass,
       modelPar_given_np_mass,
       modelPar_mu_eff,
       modelPar_given_mu_eff,
       modelPar_ksee,
       modelPar_given_ksee,
       modelPar_B,
       modelPar_given_B,
       modelPar_dqm0,
       modelPar_given_dqm0,
       modelPar_eps,
       modelPar_given_eps,
       modelPar_theta,
       modelPar_given_theta,
       modelPar_beta,
       modelPar_given_beta,
       modelPar_nd,
       modelPar_given_nd,
       // non-reals (including hidden)
       modelPar_type,
       modelPar_given_type,
       in.admsTemperature,
       in.adms_vt_nom,
       in.getDeviceOptions().gmin,
       staticContributions,
       dynamicContributions,
       in);


    // We now have the F and Q vector stuff, populate the dependencies:

    dfdp[in.admsNodeID_d+inst*(6+1)] += staticContributions[in.admsNodeID_d].dx(0);
    dqdp[in.admsNodeID_d+inst*(6+1)] += dynamicContributions[in.admsNodeID_d].dx(0);
    Findices[in.admsNodeID_d+inst*(6+1)] = in.li_d;
    Qindices[in.admsNodeID_d+inst*(6+1)] = in.li_d;
    dfdp[in.admsNodeID_g+inst*(6+1)] += staticContributions[in.admsNodeID_g].dx(0);
    dqdp[in.admsNodeID_g+inst*(6+1)] += dynamicContributions[in.admsNodeID_g].dx(0);
    Findices[in.admsNodeID_g+inst*(6+1)] = in.li_g;
    Qindices[in.admsNodeID_g+inst*(6+1)] = in.li_g;
    dfdp[in.admsNodeID_s+inst*(6+1)] += staticContributions[in.admsNodeID_s].dx(0);
    dqdp[in.admsNodeID_s+inst*(6+1)] += dynamicContributions[in.admsNodeID_s].dx(0);
    Findices[in.admsNodeID_s+inst*(6+1)] = in.li_s;
    Qindices[in.admsNodeID_s+inst*(6+1)] = in.li_s;
    dfdp[in.admsNodeID_di+inst*(6+1)] += staticContributions[in.admsNodeID_di].dx(0);
    dqdp[in.admsNodeID_di+inst*(6+1)] += dynamicContributions[in.admsNodeID_di].dx(0);
    Findices[in.admsNodeID_di+inst*(6+1)] = in.li_di;
    Qindices[in.admsNodeID_di+inst*(6+1)] = in.li_di;
    dfdp[in.admsNodeID_si+inst*(6+1)] += staticContributions[in.admsNodeID_si].dx(0);
    dqdp[in.admsNodeID_si+inst*(6+1)] += dynamicContributions[in.admsNodeID_si].dx(0);
    Findices[in.admsNodeID_si+inst*(6+1)] = in.li_si;
    Qindices[in.admsNodeID_si+inst*(6+1)] = in.li_si;
    dfdp[in.admsNodeID_sf+inst*(6+1)] += staticContributions[in.admsNodeID_sf].dx(0);
    dqdp[in.admsNodeID_sf+inst*(6+1)] += dynamicContributions[in.admsNodeID_sf].dx(0);
    Findices[in.admsNodeID_sf+inst*(6+1)] = in.li_sf;
    Qindices[in.admsNodeID_sf+inst*(6+1)] = in.li_sf;
    dfdp[in.admsBRA_ID_sf_GND+inst*(6+1)] += staticContributions[in.admsBRA_ID_sf_GND].dx(0);
    dqdp[in.admsBRA_ID_sf_GND+inst*(6+1)] += dynamicContributions[in.admsBRA_ID_sf_GND].dx(0);
    Findices[in.admsBRA_ID_sf_GND+inst*(6+1)] = in.li_BRA_sf_GND;
    Qindices[in.admsBRA_ID_sf_GND+inst*(6+1)] = in.li_BRA_sf_GND;
  }

}

#endif // Xyce_ADMS_SENSITIVITIES

} // namespace ADMSmvs_2_0_0_hemt
} // namespace Device
} // namespace Xyce
